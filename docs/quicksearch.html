<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Source: index.js // external dependencies import isArray from 'lodash/isArray'; import isPlainObject from 'lodash/isPlainObject'; // Crio import { CrioArray, CrioObject } from './Crio'; // utils import { isCrio } from './utils'; /** * @module crio */ /** * @function crio * * @description * build a new crio object based on the object passed * * @param {*} [object={}] object to convert to crio * * @returns {CrioArray|CrioObject} object that has been crioed */ const crio = (object = {}) =&gt; { if (isArray(object)) { return new CrioArray(object); } if (isPlainObject(object)) { return new CrioObject(object); } if (isCrio(object)) { return object; } throw new TypeError('Object passed must be either an array or a plain object.'); }; /** * @function crio.array * * @description * convenience method for making crio arrays * * @param {Array&lt;*&gt;} array array to crio * @returns {CrioArray} crio array */ crio.array = (array = []) =&gt; { if (!isArray(array)) { throw new TypeError('Object passed must be an array.'); } return crio(array); }; /** * @function crio.isArray * * @description * check if object is a crio array * * @param {*} object object to test * @returns {boolean} is the object a crio array */ crio.isArray = (object) =&gt; { return isCrio(object) &amp;&amp; object.isArray(); }; crio.isCrio = isCrio; /** * @function crio.isObject * * @description * check if object is a crio object * * @param {*} object object to test * @returns {boolean} is the object a crio object */ crio.isObject = (object) =&gt; { return isCrio(object) &amp;&amp; object.isObject(); }; /** * @function crio.object * * @description * convenience method for making crio objects * * @param {Object} object object to crio * @returns {CrioObject} crio object */ crio.object = (object = {}) =&gt; { if (!isPlainObject(object)) { throw new TypeError('Object passed must be a plain object.'); } return crio(object); }; export default crio; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Crio.js.html":{"id":"Crio.js.html","title":"Source: Crio.js","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Source: Crio.js // external dependencies import hashIt from 'hash-it'; import every from 'lodash/every'; import fill from 'lodash/fill'; import find from 'lodash/find'; import findKey from 'lodash/findKey'; import findLastKey from 'lodash/findLastKey'; import isArray from 'lodash/isArray'; import isUndefined from 'lodash/isUndefined'; import filter from 'lodash/filter'; import forEach from 'lodash/forEach'; import get from 'lodash/fp/get'; import keys from 'lodash/keys'; import map from 'lodash/map'; import merge from 'lodash/merge'; import reduce from 'lodash/reduce'; import reduceRight from 'lodash/reduceRight'; import reverse from 'lodash/fp/reverse'; import set from 'lodash/fp/set'; import slice from 'lodash/slice'; import some from 'lodash/some'; import sortBy from 'lodash/fp/sortBy'; import toPairs from 'lodash/toPairs'; import values from 'lodash/values'; // constants import { CRIO_ARRAY_TYPE, CRIO_OBJECT_TYPE, CRIO_SYMBOL, CRIO_TYPE, ITERATOR_PROPERTY_DESCRIPTOR, UNSCOPABLES_PROPERTY_DESCRIPTOR } from './constants'; // utils import { createAssignToObject, freeze, getCorrectConstructor, getCrioValue, getKeysMetadata, getRelativeValue, getStandardValue, isCrio, isCrioArray, isEqual, stringify } from './utils'; /** * @module Crio */ let assignToObject; /** * @class Crio * @classdesc base crio class * * @memberof module:Crio */ export class Crio { /** * @function constructor * * @description * add the items to the crio, and return a frozen version * * @param {Object} object object passed for crioing * @returns {Crio} crioed object */ constructor(object) { forEach(object, assignToObject(this, getCrioValue)); return freeze(this); } /** * @static */ static get ['@@species']() { return this; } get [CRIO_SYMBOL]() { return true; } get hashCode() { return hashIt(this); } /** * @function clear * @memberof! Crio# * * @description * get a new crio that is empty * * @returns {Crio} new empty crio instance */ clear() { return new this.constructor(this.isArray() ? [] : {}); } /** * @function compact * * @description * remove all falsy values from the crio * * @returns {Crio} new crio instance */ compact() { return this.filter((value) =&gt; { return !!value; }); } /** * @function delete * * @description * remove an item from the crio * * @param {number|string} key the key to remove from the crio * @returns {Crio} new crio instance with item removed */ delete(key) { let updated = {...this}; delete updated[key]; if (this.isArray()) { updated = map(updated); } return new this.constructor(updated); } /** * @function deleteIn * * @description * remove a nested item from the crio * * @param {Array&lt;number|string&gt;} keys the path of the item to remove * @returns {Crio} new crio instance with the item removed */ deleteIn(keys) { if (!keys || !keys.length) { return this; } if (keys.length === 1) { return this.delete(keys[0]); } const { currentValue, lastIndex, parentKeys } = getKeysMetadata(keys, this); if (!isCrio(currentValue)) { return this; } const updated = currentValue.delete(keys[lastIndex]); return this.setIn(parentKeys, updated); } /** * @function entries * * @description * get the pairs of [key, value] in the crio * * @returns {Array&lt;Array&lt;string&gt;&gt;} [key, value] pairs */ entries() { return toPairs(this); } /** * @function equals * * @description * does the object passed equal the crio * * @param {*} object object to compare against the instance * @returns {boolean} is the object equal */ equals(object) { return isEqual(this, object); } /** * @function every * * @description * does every instance in the crio match * * @param {function} fn the function to test for matching * @param {*} [thisArg=this] argument for &quot;this&quot; to use in the iteration * @returns {boolean} does every instance match */ every(fn, thisArg = this) { return every(this, fn, thisArg); } /** * @function filter * * @description * get a reduced set from the crio * * @param {function} fn function to test for if it should be returned or not * @param {*} [thisArg=this] argument for &quot;this&quot; to use in the iteration * @returns {Crio} new crio instance */ filter(fn, thisArg = this) { const updated = this.isArray() ? filter(this, fn, thisArg) : reduce(this, (updatedValue, value, key) =&gt; { if (fn.call(thisArg, value, key, this)) { updatedValue[key] = value; } return updatedValue; }, {}); return new this.constructor(updated); } /** * @function find * * @description * find an item in the crio if it exists * * @param {function} fn function to test for finding the item * @param {number} [fromKey] key to start from when performing the find * @returns {*} found item or undefined */ find(fn, fromKey) { return find(this, fn, fromKey); } /** * @function forEach * * @description * iterate over the crio calling fn * * @param {function} fn function to call in iteration * @param {*} [thisArg=this] argument to use as &quot;this&quot; in the iteration * @returns {Crio} new crio instance */ forEach(fn, thisArg = this) { forEach(this, fn, thisArg); return this; } /** * @function get * * @description * get the item at key passed * * @param {number|string} key key to retrieve * @returns {*} item found at key */ get(key) { return this[key]; } /** * @function getIn * * @description * get the nested item at the path passed * * @param {Array&lt;number|string&gt;} keys path to retrieve from * @returns {*} item found at nested path */ getIn(keys) { if (!keys || !keys.length) { return this; } return get(keys, this); } /** * @function has * * @description * does the crio have the key passed * * @param {number|string} key key to test * @returns {boolean} does the crio have the key */ has(key) { return this.hasOwnProperty(key); } /** * @function hasIn * * @description * does the crio have the nested key at the path passed * * @param {Array&lt;number|string&gt;} keys path to test * @returns {boolean} does the crio have the nested path */ hasIn(keys) { if (!keys || !keys.length) { return false; } if (keys.length === 1) { return this.has(keys[0]); } const { currentValue, lastIndex } = getKeysMetadata(keys, this); return isCrio(currentValue) &amp;&amp; currentValue.has(keys[lastIndex]); } /** * @function includes * * @description * does the crio have the value passed * * @param {*} value value to test for existence * @returns {boolean} does the value exist in the crio */ includes(value) { return this.some((currentValue) =&gt; { return currentValue === value; }); } /** * @function isArray * * @description * is the crio an array * * @returns {boolean} is the crio an array */ isArray() { return this[CRIO_TYPE] === CRIO_ARRAY_TYPE; } /** * @function isObject * * @description * is the crio an object * * @returns {boolean} is the crio an object */ isObject() { return this[CRIO_TYPE] === CRIO_OBJECT_TYPE; } /** * @function keys * * @description * get the keys of the crio * * @returns {Array&lt;string&gt;} keys in the crio */ keys() { return keys(this); } /** * @function map * * @description * iterate over the crio mapping the result of fn to the key * * @param {function} fn function to call on iteration * @param {*} [thisArg=this] argument to use as &quot;this&quot; in the iteration * @returns {Crio} new crio instance */ map(fn, thisArg = this) { const updated = this.isArray() ? map(this, fn, thisArg) : reduce(this, (updatedValue, value, key) =&gt; { updatedValue[key] = fn.call(thisArg, value, key, this); return updatedValue; }, {}); return new this.constructor(updated); } /** * @function merge * * @description * merge objects with crio * * @param {...Array&lt;CrioArray|CrioObject|Object&gt;} objects objects to merge with the crio * @returns {Crio} new crio instance */ merge(...objects) { if (!objects.length) { return this; } const merged = merge({}, this.thaw(), ...objects); return new this.constructor(merged); } /** * @function mergeIn * * @description * merge the objects passed at the nested path in the crioArray * * @param {Array&lt;number|string&gt;} keys path to merge into * @param {...Array&lt;CrioArray|CrioObject|Object&gt;} objects objects to merge with the crio * @returns {Crio} new crio instance */ mergeIn(keys, ...objects) { if (!keys || !keys.length) { return this; } const valueToMerge = this.getIn(keys); if (!isCrio(valueToMerge)) { return this.setIn(keys, merge({}, ...objects)); } const updated = this.setIn(keys, valueToMerge.merge(...objects)); return new this.constructor(updated); } /** * @function mutate * * @description * work with the object in a mutated way and return the crioed result of that call * * @param {function} fn function to apply to crio * @param {*} [thisArg=this] argument to use for &quot;this&quot; in the call * @returns {*} crioed value resulting from the call */ mutate(fn, thisArg = this) { const result = fn.call(thisArg, this.thaw(), this); return getCrioValue(result, getCorrectConstructor(result, CrioArray, CrioObject)); } /** * @function pluck * * @description * get the values in each object in the collection at key * * @param {string} key key to find value of in collection object * @returns {Crio} new crio instance */ pluck(key) { let plucked; return this.reduce((pluckedValues, value) =&gt; { plucked = !!(value &amp;&amp; value.hasOwnProperty(key)) ? value[key] : undefined; return [ ...pluckedValues, plucked ]; }, []); } /** * @function pluckIn * * @description * get the values in each object in the collection at the nested path * * @param {Array&lt;number|string&gt;} keys keys to find value of in collection object * @returns {Crio} new crio instance */ pluckIn(keys) { if (!keys || !keys.length) { return new CrioArray([]); } if (keys.length === 1) { return this.pluck(keys[0]); } const { currentValue, lastIndex } = getKeysMetadata(keys, this); if (!isCrio(currentValue)) { return this; } return currentValue.pluck(keys[lastIndex]); } /** * @function reduce * * @description * reduce the crio down to a single value, starting with initial value * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @param {*} [thisArg=this] argument to use for &quot;this&quot; in the call of fn * @returns {*} the reduced value */ reduce(fn, initialValue, thisArg = this) { const reducedValue = reduce(this, fn, initialValue, thisArg); return getCrioValue(reducedValue, getCorrectConstructor(reducedValue, CrioArray, CrioObject)); } /** * @function reduceRight * * @description * reduce the crio down to a single value, starting with initial value, in reverse order * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @param {*} [thisArg=this] argument to use for &quot;this&quot; in the call of fn * @returns {*} the reduced value */ reduceRight(fn, initialValue, thisArg = this) { const reducedValue = reduceRight(this, fn, initialValue, thisArg); return getCrioValue(reducedValue, getCorrectConstructor(reducedValue, CrioArray, CrioObject)); } /** * @function set * * @description * set the value at the key passed * * @param {number|string} key key to assign value to * @param {*} value value to assign * @returns {Crio} new crio instance */ set(key, value) { const updated = { ...this, [key]: value }; return new this.constructor(updated); } /** * @function setIn * * @description * deeply set the value at the path passed * * @param {Array&lt;number|string&gt;} keys path to assign value to * @param {*} value value to assign * @returns {Crio} new crio instance */ setIn(keys, value) { if (!keys || !keys.length) { return this; } const updatedObject = set(keys, value, this); return new this.constructor(updatedObject); } /** * @function some * * @description * do any of the items in crio match per the fn passed * * @param {function} fn fn to iterate with * @param {*} [thisArg=this] argument to use as &quot;this&quot; in the iteration * @returns {boolean} are there any matches */ some(fn, thisArg = this) { return some(this, fn, thisArg); } /** * @function thaw * * @description * create a plain JS version of the crio * * @returns {Array&lt;*&gt;|Object} plain JS version of crio */ thaw() { let returnValue = this.isArray() ? [] : {}; forEach(this, assignToObject(returnValue, getStandardValue)); return returnValue; } /** * @function toArray * * @description * convert the crio to an array if it isnt already * * @returns {CrioArray} new crio array instance */ toArray() { if (this.isArray()) { return this; } return new CrioArray(this.values()); } /** * @function toLocaleString * * @description * convert the crio to stringified form * * @returns {string} stringified crio */ toLocaleString() { return this.toString(); } /** * @function toObject * * @description * convert the crio to an object if it isnt already * * @returns {CrioObject} new crio object instance */ toObject() { if (this.isObject()) { return this; } const updated = reduce(this, (object, value, key) =&gt; { object[key] = value; return object; }, {}); return new CrioObject(updated); } /** * @function toLocaleString * * @description * convert the crio to stringified form * * @returns {string} stringified crio */ toString() { return stringify(this); } /** * @function valueOf * * @description * noop for valueOf * * @returns {Crio} the same crio instance */ valueOf() { return this; } /** * @function values * * @description * get the values of the crio as an array * * @returns {Array&lt;*&gt;} values in the crio */ values() { return values(this); } } Object.defineProperties(Crio.prototype, { [Symbol.iterator]: ITERATOR_PROPERTY_DESCRIPTOR, [Symbol.unscopables]: UNSCOPABLES_PROPERTY_DESCRIPTOR }); /** * @class CrioArray * @classdesc extension of Crio class specific to arrays * * @memberof module:Crio */ export class CrioArray extends Crio { get length() { return Object.keys(this).length; } /** * @function concat * * @description * append the items passed to the crio * * @param {...Array&lt;*&gt;} items items to append to the crio * @returns {CrioArray} new crio array instance */ concat(items) { return new CrioArray([ ...this, ...items ]); } /** * @function copyWithin * * @description * move values around within the array * * @param {number} target target to copy * @param {number} [start=0] index to start copying to * @param {number} [end=this.length] index to stop copying to * @returns {CrioArray} new crio array instance */ copyWithin(target, start = 0, end = this.length) { const copiedArray = [...this]; const length = this.length &gt;&gt;&gt; 0; let to = getRelativeValue(target &gt;&gt; 0, length), from = getRelativeValue(start &gt;&gt; 0, length); const final = getRelativeValue(end &gt;&gt; 0, length); let count = Math.min(final - from, length - to), direction = 1; if (from &lt; to &amp;&amp; to &lt; (from + count)) { direction = -1; from += count - 1; to += count - 1; } while (count &gt; 0) { if (from in copiedArray) { copiedArray[to] = copiedArray[from]; } else { delete copiedArray[to]; } from += direction; to += direction; count--; } return new CrioArray(copiedArray); } /** * @function difference * * @description * find the values in this that do not exist in any of the arrays passed * * @param {Array&lt;Array&gt;} arrays arrays to get the difference of * @returns {CrioArray} array of items matching diffference criteria */ difference(...arrays) { if (!arrays.length) { return this; } let indexOfValue; const difference = reduce(arrays, (differenceArray, array) =&gt; { if (isArray(array) || isCrioArray(array)) { forEach(array, (value) =&gt; { indexOfValue = differenceArray.indexOf(value); if (!!~indexOfValue) { differenceArray.splice(indexOfValue, 1); } }); } return differenceArray; }, [...this]); return new CrioArray(difference); } /** * @function fill * * @description * fill the array at certain indices with the value passed * * @param {*} value the value to fill the indices with * @param {number} [start=0] the starting index to fill * @param {number} [end=this.length] the ending index to fill * @returns {CrioArray} new crio array instance */ fill(value, start = 0, end = this.length) { const filled = fill(this.thaw(), value, start, end); return new CrioArray(filled, this); } /** * @function findIndex * * @description * find the matching index based on truthy return from fn * * @param {function} fn function to use for test in iteration * @param {*} [thisArg=this] argument to use as &quot;this&quot; in fn call * @returns {number} index of match, or -1 */ findIndex(fn, thisArg = this) { const index = findKey(this, (value, index) =&gt; { return fn.call(thisArg, value, +index, this); }); return isUndefined(index) ? -1 : +index; } /** * @function findLastIndex * * @description * find the matching index based on truthy return from fn starting from end * * @param {function} fn function to use for test in iteration * @param {*} [thisArg=this] argument to use as &quot;this&quot; in fn call * @returns {number} index of match, or -1 */ findLastIndex(fn, thisArg = this) { const index = findLastKey(this, (value, index) =&gt; { return fn.call(thisArg, value, +index, this); }); return isUndefined(index) ? -1 : +index; } /** * @function first * * @description * take the first n number of items in the array * * @param {number} [size=1] size of elements to take from beginning of array * @returns {CrioArray} */ first(size = 1) { return this.slice(0, size); } /** * @function indexOf * * @description * get the index of the value passed * * @param {*} value value to find in crio * @returns {number} index of match, or -1 */ indexOf(value) { return this.findIndex((thisValue) =&gt; { return thisValue === value; }); } /** * @function intersection * * @description * find the values in that exist in this and each of the arrays passed * * @param {Array&lt;Array&gt;} arrays * @returns {CrioArray} */ intersection(...arrays) { if (!arrays.length) { return this; } const allArrays = [ this, ...arrays ]; const allArraysLength = allArrays.length; let indices = [], indexOfValue; const reducedArrays = reduce(allArrays, (values, array) =&gt; { if (isArray(array) || isCrioArray(array)) { forEach(array, (value) =&gt; { indexOfValue = values.indexOf(value); if (!!~indexOfValue) { indices[indexOfValue]++; } else { indices[values.length] = 1; values.push(value); } }); } return values; }, []); const filteredArrays = filter(reducedArrays, (value, index) =&gt; { return indices[index] === allArraysLength; }); return new CrioArray(filteredArrays); } /** * @function join * * @description * join the values in the crio as a string, combined with separator * * @param {string} [separator=','] character(s) to place between strings in combination * @returns {string} parameters joined by separator in string */ join(separator = ',') { return [...this].join(separator); } /** * @function last * * @description * take the last n number of items in the array * * @param {number} [size=1] size of elements to take from end of array * @returns {CrioArray} */ last(size = 1) { return this.slice(this.length - size); } /** * @function lastIndexOf * * @description * get the last index of the value passed * * @param {*} value value to find in crio * @returns {number} index of match, or -1 */ lastIndexOf(value) { return this.findLastIndex((thisValue) =&gt; { return thisValue === value; }); } /** * @function pop * * @description * get crio based on current crio with last item removed * * @returns {CrioArray} new crio array instance */ pop() { return this.slice(0, this.length - 1); } /** * @function reverse * * @description * get the same values, but in reverse order * * @returns {CrioArray} new crio array instance */ reverse() { const reversed = reverse(this); return new CrioArray(reversed); } /** * @function shift * * @description * get crio based on current crio with first item removed * * @returns {CrioArray} new crio array instance */ shift() { return this.slice(1); } /** * @function slice * * @description * get a new crio array based on a subset of the current crio * * @param {number} [start=0] first index to include * @param {number} [end=this.length] size of array from first index * @returns {CrioArray} new crio array instance */ slice(start = 0, end = this.length) { const sliced = slice(this, start, end); return new CrioArray(sliced); } /** * @function sort * * @description * sort the collection by the fn passed * * @param {function} fn the function to sort based on * @returns {CrioArray} new crio array instance */ sort(fn) { const sorted = sortBy(fn, this); return new CrioArray(sorted); } /** * @function splice * * @description * splice the values into or out of the array * * @param {number} [start=0] starting index to splice * @param {number} [deleteCount=1] length from starting index to removes * @param {...Array&lt;*&gt;} items items to insert after delete is complete * @returns {CrioArray} new crio array instance */ splice(start = 0, deleteCount = 1, ...items) { let spliced = [...this]; spliced.splice(start, deleteCount, ...items); return new CrioArray(spliced); } /** * @function unique * * @description * return the current CrioArray with the duplicate values removed * * @returns {CrioArray} new crio instance */ unique() { let hashArray = [], newArray = [], hasHashCode = false, hashCode, storeValue; return this.filter((value) =&gt; { hashCode = !!value ? value.hashCode : undefined; hasHashCode = !isUndefined(hashCode); storeValue = !~newArray.indexOf(value) &amp;&amp; (!hasHashCode || !~hashArray.indexOf(hashCode)); if (storeValue) { newArray.push(value); if (hasHashCode) { hashArray.push(hashCode); } } return storeValue; }); } /** * @function unshift * * @description * add items passed to the beginning of the crio array * * @param {...Array&lt;*&gt;} items items to prepend to the array * @returns {CrioArray} new crio array instance */ unshift(...items) { if (!items.length) { return this; } return new CrioArray([ ...items, ...this ]); } /** * @function xor * * @description * find the values that are the symmetric difference of this and the arrays passed * * @param {Array&lt;Array&gt;} arrays arrays to find symmetric values in * @returns {CrioArray} new crio array instance */ xor(...arrays) { if (!arrays.length) { return this; } const allArrays = [ this, ...arrays ]; let indicesToRemove = [], indexOfValue; const reducedValues = reduce(allArrays, (values, array) =&gt; { if (isArray(array) || isCrioArray(array)) { forEach(array, (value) =&gt; { indexOfValue = values.indexOf(value); if (!!~indexOfValue) { indicesToRemove.push(indexOfValue); } else { values.push(value); } }); } return values; }, []); const xorValues = filter(reducedValues, (value, index) =&gt; { return !~indicesToRemove.indexOf(index); }); return new CrioArray(xorValues); } } Object.defineProperties(CrioArray.prototype, { [CRIO_TYPE]: { configurable: false, enumerable: false, value: CRIO_ARRAY_TYPE, writable: false } }); /** * @class CrioObject * @classdesc extension of Crio class specific to objects * * @memberof module:Crio */ export class CrioObject extends Crio { get size() { return Object.keys(this).length; } /** * @function findKey * * @description * find a specific key based on a matching function * * @param {function} fn function to match * @returns {string|undefined} key matching fn */ findKey(fn) { return findKey(this, fn); } /** * @function findLastKey * * @description * find a specific key based on a matching function, starting from the end * * @param {function} fn function to match * @returns {string|undefined} key matching fn */ findLastKey(fn) { return findLastKey(this, fn); } } Object.defineProperties(CrioObject.prototype, { [CRIO_TYPE]: { configurable: false, enumerable: false, value: CRIO_OBJECT_TYPE, writable: false } }); assignToObject = createAssignToObject(CrioArray, CrioObject); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Modules Classes Crio CrioArray CrioObject × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Classes Classes Crio CrioArray CrioObject × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Tutorials Classes Crio CrioArray CrioObject × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API crio 4.0.0 crio Immutable JS objects with a natural API Jump to the API API Documentation Import into your project // ES2015 import crio from 'crio'; // CommonJS const crio = require('crio'); // UMD const crio = window.crio;Usage // you can assign with crio() directly const crioArray = crio(['foo']); const crioObject = crio({foo: 'bar'}); // or use the convenience methods const otherCrioArray = crio.array(['bar']); const otherCrioObject = crio.object({bar: 'baz'});What is immutable? When something is described as immutable, it means that it cannot change after it has been created. In JavaScript terms, this means that any attempted change to an object results in a brand new object being created, without changing the original object. Why do we need this in JavaScript? The concept of immutability already exists in a lot of places in JavaScript, for example: const two = 2; const three = 3; const five = two + three;By adding together two and three you expect to get five, however you don't expect the value of two to change. You can continue working with it even after using it in an expression: const two = 2; const three = 3; const five = two + three; const four = two * two;This is true of strings, numbers, undefined, and null, and is an expected behavior. The same idea, however, is not true for complex objects in JavaScript. For example: const foo = ['foo']; const fooBar = foo.push('bar');The expectation is that you have pushed the value of &quot;bar&quot; into foo and created a new array bar that contains &quot;foo, bar&quot;, however in reality this is what happens: const foo = ['foo']; const fooBar = foo.push('bar'); console.log(foo); // ['foo', 'bar'] console.log(fooBar); // 1Basically, you have mutated foo so that it is no longer empty, and what the .push() method returns is actually the index of the item you just added. This double-standard of expectations creates a lot confusion from a development perspective, but also makes keeping track of the state of your application very difficult because there is no traceability of what transactions have occurred to create that state at any given point. Enter crio crio attempts to solve the problem by closing the &quot;immutable loop&quot; on collection items, meaning it applies immutability to objects that are normally mutable by nature by replacing mutating methods with immutable counterparts. As a point of reference: Naturally immutable objects Numbers Strings undefined null Naturally mutable objects Arrays Dates (not covered by crio) Objects To create a new crio object, its pretty straightforward: const crioArray = crio([]); const crioObject = crio({}); // or just crio()These are examples with empty objects, but you can pass in populated objects as well, or if you pass in nothing it will default to an object. What crio does is clone and freeze the object via Object.freeze, and stores as a custom CrioArray or CrioObject with a prototypical methods that will return a new immutable version of the object with each update. Example: const foo = crio(['foo']); const fooBar = foo.push('bar'); console.log(foo); // ['foo'] console.log(fooBar); // ['foo', 'bar']The API is the same as you already know working with those objects, and includes polyfills for all ES6 and some ES7 functions, as well as a few helpful crio-specific functions. The only difference is that any setting happens via .set() rather than direct index / property setting. You can work with the objects as you normally would with other libraries (lodash, for example). There is also no change to the protoypes of native objects, so you can apply this on your existing code go-forward. Basically, you shouldn't even notice you aren't working with the native objects, save for the fact everything is immutable. Why not just use X immutable library? There are a bunch of ones out there, but the two that people usually gravitate towards: Immutable.js seamless-immutable immutable is quite nice, and very highly regarded by the community, however it creates an opaque object that cannot be used with other external libraries (namely lodash) without converting back to vanilla JS. Additionally, the object itself is not truly immutable, just constructed in a way that makes it incredibly difficult to alter outside of the API. This decision was likely made for performance reasons, but can cause unintended consequences (you can totally assign foo.bar = 'baz' and no error is thrown). seamless-immutable has some great ideas, and I thought that could be the best option because they try to retain the native operations while leveraging Object.freeze, much like crio does. That said, they do not try to replace mutable methods with immutable ones, they just throw errors when you attempt them and its up to you to figure out the &quot;right way&quot;. As such, it fell short of my expectations. Bottom line, I support each of these projects to the fullest because they are trying to instill immutability in JavaScript practices; I just took a different approach that I consider the best of both worlds. :) Browser support The only requirement is that your browser has a proper ES5 environment, which you can mostly shim with something like es5-shim, however certain things like Object.defineProperty cannot be shimmed, so IE8 and below cannot be supported. crio has been tested on the following browsers: Chrome Firefox Edge IE9 Performance As of 4.0.0, performance has substantially improved, and in many scenarios crio is more performant than seamless-immutable (in the case of setIn, by over 3x). When it comes to get operations (either directly or nested), crio is identical to native in performance. I don't want to post benchmarks because those vary wildly from machine to machine, but feel free to test them out yourself! Gotchas Recursive objects are not allowed Immutable objects with recursive values are basically impossible, and trying them will cause a stack overflow, so be mindful of that! Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: benchmark =&gt; run benchmarks in node benchmark:watch =&gt; run benchmark with persistent watcher for changes build =&gt; run webpack to build crio.js with NODE_ENV=development build:minifed =&gt; run webpack to build crio.min.js with NODE_ENV=production compile-for-publish =&gt; run lint, test, transpile, dist dev =&gt; run webpack dev server to run example app (playground!) dev:production =&gt; runs dev but with NODE_ENV=production dist =&gt; runs build and build-minified lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish test =&gt; run AVA test functions with NODE_ENV=test test:watch =&gt; same as test, but runs persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-Crio.html":{"id":"module-Crio.html","title":"Module: Crio","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Module: Crio Source: Crio.js, line 129 Classes Crio CrioArray CrioObject Methods &lt;inner&gt; compact() remove all falsy values from the crio Source: Crio.js, line 182 Returns: new crio instance Type Crio &lt;inner&gt; concat(items) append the items passed to the crio Parameters: Name Type Argument Description items Array.&lt;*&gt; &lt;repeatable&gt; items to append to the crio Source: Crio.js, line 948 Returns: new crio array instance Type CrioArray &lt;inner&gt; constructor(object) add the items to the crio, and return a frozen version Parameters: Name Type Description object Object object passed for crioing Source: Crio.js, line 143 Returns: crioed object Type Crio &lt;inner&gt; copyWithin(target [, start] [, end]) move values around within the array Parameters: Name Type Argument Default Description target number target to copy start number &lt;optional&gt; 0 index to start copying to end number &lt;optional&gt; this.length index to stop copying to Source: Crio.js, line 961 Returns: new crio array instance Type CrioArray &lt;inner&gt; delete(key) remove an item from the crio Parameters: Name Type Description key number | string the key to remove from the crio Source: Crio.js, line 199 Returns: new crio instance with item removed Type Crio &lt;inner&gt; deleteIn(keys) remove a nested item from the crio Parameters: Name Type Description keys Array.&lt;(number|string)&gt; the path of the item to remove Source: Crio.js, line 223 Returns: new crio instance with the item removed Type Crio &lt;inner&gt; difference(arrays) find the values in this that do not exist in any of the arrays passed Parameters: Name Type Description arrays Array.&lt;Array&gt; arrays to get the difference of Source: Crio.js, line 1011 Returns: array of items matching diffference criteria Type CrioArray &lt;inner&gt; entries() get the pairs of [key, value] in the crio Source: Crio.js, line 258 Returns: [key, value] pairs Type Array.&lt;Array.&lt;string&gt;&gt; &lt;inner&gt; equals(object) does the object passed equal the crio Parameters: Name Type Description object * object to compare against the instance Source: Crio.js, line 273 Returns: is the object equal Type boolean &lt;inner&gt; every(fn [, thisArg]) does every instance in the crio match Parameters: Name Type Argument Default Description fn function the function to test for matching thisArg * &lt;optional&gt; this argument for &quot;this&quot; to use in the iteration Source: Crio.js, line 289 Returns: does every instance match Type boolean &lt;inner&gt; fill(value [, start] [, end]) fill the array at certain indices with the value passed Parameters: Name Type Argument Default Description value * the value to fill the indices with start number &lt;optional&gt; 0 the starting index to fill end number &lt;optional&gt; this.length the ending index to fill Source: Crio.js, line 1051 Returns: new crio array instance Type CrioArray &lt;inner&gt; filter(fn [, thisArg]) get a reduced set from the crio Parameters: Name Type Argument Default Description fn function function to test for if it should be returned or not thisArg * &lt;optional&gt; this argument for &quot;this&quot; to use in the iteration Source: Crio.js, line 308 Returns: new crio instance Type Crio &lt;inner&gt; find(fn [, fromKey]) find an item in the crio if it exists Parameters: Name Type Argument Description fn function function to test for finding the item fromKey number &lt;optional&gt; key to start from when performing the find Source: Crio.js, line 337 Returns: found item or undefined Type * &lt;inner&gt; findIndex(fn [, thisArg]) find the matching index based on truthy return from fn Parameters: Name Type Argument Default Description fn function function to use for test in iteration thisArg * &lt;optional&gt; this argument to use as &quot;this&quot; in fn call Source: Crio.js, line 1074 Returns: index of match, or -1 Type number &lt;inner&gt; findKey(fn) find a specific key based on a matching function Parameters: Name Type Description fn function function to match Source: Crio.js, line 1523 Returns: key matching fn Type string | undefined &lt;inner&gt; findLastIndex(fn [, thisArg]) find the matching index based on truthy return from fn starting from end Parameters: Name Type Argument Default Description fn function function to use for test in iteration thisArg * &lt;optional&gt; this argument to use as &quot;this&quot; in fn call Source: Crio.js, line 1099 Returns: index of match, or -1 Type number &lt;inner&gt; findLastKey(fn) find a specific key based on a matching function, starting from the end Parameters: Name Type Description fn function function to match Source: Crio.js, line 1536 Returns: key matching fn Type string | undefined &lt;inner&gt; first( [size]) take the first n number of items in the array Parameters: Name Type Argument Default Description size number &lt;optional&gt; 1 size of elements to take from beginning of array Source: Crio.js, line 1124 Returns: Type CrioArray &lt;inner&gt; forEach(fn [, thisArg]) iterate over the crio calling fn Parameters: Name Type Argument Default Description fn function function to call in iteration thisArg * &lt;optional&gt; this argument to use as &quot;this&quot; in the iteration Source: Crio.js, line 354 Returns: new crio instance Type Crio &lt;inner&gt; get(key) get the item at key passed Parameters: Name Type Description key number | string key to retrieve Source: Crio.js, line 375 Returns: item found at key Type * &lt;inner&gt; getIn(keys) get the nested item at the path passed Parameters: Name Type Description keys Array.&lt;(number|string)&gt; path to retrieve from Source: Crio.js, line 391 Returns: item found at nested path Type * &lt;inner&gt; has(key) does the crio have the key passed Parameters: Name Type Description key number | string key to test Source: Crio.js, line 411 Returns: does the crio have the key Type boolean &lt;inner&gt; hasIn(keys) does the crio have the nested key at the path passed Parameters: Name Type Description keys Array.&lt;(number|string)&gt; path to test Source: Crio.js, line 427 Returns: does the crio have the nested path Type boolean &lt;inner&gt; includes(value) does the crio have the value passed Parameters: Name Type Description value * value to test for existence Source: Crio.js, line 455 Returns: does the value exist in the crio Type boolean &lt;inner&gt; indexOf(value) get the index of the value passed Parameters: Name Type Description value * value to find in crio Source: Crio.js, line 1142 Returns: index of match, or -1 Type number &lt;inner&gt; intersection(arrays) find the values in that exist in this and each of the arrays passed Parameters: Name Type Description arrays Array.&lt;Array&gt; Source: Crio.js, line 1160 Returns: Type CrioArray &lt;inner&gt; isArray() is the crio an array Source: Crio.js, line 473 Returns: is the crio an array Type boolean &lt;inner&gt; isObject() is the crio an object Source: Crio.js, line 488 Returns: is the crio an object Type boolean &lt;inner&gt; join( [separator]) join the values in the crio as a string, combined with separator Parameters: Name Type Argument Default Description separator string &lt;optional&gt; ',' character(s) to place between strings in combination Source: Crio.js, line 1210 Returns: parameters joined by separator in string Type string &lt;inner&gt; keys() get the keys of the crio Source: Crio.js, line 503 Returns: keys in the crio Type Array.&lt;string&gt; &lt;inner&gt; last( [size]) take the last n number of items in the array Parameters: Name Type Argument Default Description size number &lt;optional&gt; 1 size of elements to take from end of array Source: Crio.js, line 1228 Returns: Type CrioArray &lt;inner&gt; lastIndexOf(value) get the last index of the value passed Parameters: Name Type Description value * value to find in crio Source: Crio.js, line 1246 Returns: index of match, or -1 Type number &lt;inner&gt; map(fn [, thisArg]) iterate over the crio mapping the result of fn to the key Parameters: Name Type Argument Default Description fn function function to call on iteration thisArg * &lt;optional&gt; this argument to use as &quot;this&quot; in the iteration Source: Crio.js, line 518 Returns: new crio instance Type Crio &lt;inner&gt; merge(objects) merge objects with crio Parameters: Name Type Argument Description objects Array.&lt;(CrioArray|CrioObject|Object)&gt; &lt;repeatable&gt; objects to merge with the crio Source: Crio.js, line 545 Returns: new crio instance Type Crio &lt;inner&gt; mergeIn(keys, objects) merge the objects passed at the nested path in the crioArray Parameters: Name Type Argument Description keys Array.&lt;(number|string)&gt; path to merge into objects Array.&lt;(CrioArray|CrioObject|Object)&gt; &lt;repeatable&gt; objects to merge with the crio Source: Crio.js, line 571 Returns: new crio instance Type Crio &lt;inner&gt; mutate(fn [, thisArg]) work with the object in a mutated way and return the crioed result of that call Parameters: Name Type Argument Default Description fn function function to apply to crio thisArg * &lt;optional&gt; this argument to use for &quot;this&quot; in the call Source: Crio.js, line 604 Returns: crioed value resulting from the call Type * &lt;inner&gt; pluck(key) get the values in each object in the collection at key Parameters: Name Type Description key string key to find value of in collection object Source: Crio.js, line 625 Returns: new crio instance Type Crio &lt;inner&gt; pluckIn(keys) get the values in each object in the collection at the nested path Parameters: Name Type Description keys Array.&lt;(number|string)&gt; keys to find value of in collection object Source: Crio.js, line 647 Returns: new crio instance Type Crio &lt;inner&gt; pop() get crio based on current crio with last item removed Source: Crio.js, line 1264 Returns: new crio array instance Type CrioArray &lt;inner&gt; reduce(fn, initialValue [, thisArg]) reduce the crio down to a single value, starting with initial value Parameters: Name Type Argument Default Description fn function the function to iterate with initialValue * the initial value of the reduction thisArg * &lt;optional&gt; this argument to use for &quot;this&quot; in the call of fn Source: Crio.js, line 679 Returns: the reduced value Type * &lt;inner&gt; reduceRight(fn, initialValue [, thisArg]) reduce the crio down to a single value, starting with initial value, in reverse order Parameters: Name Type Argument Default Description fn function the function to iterate with initialValue * the initial value of the reduction thisArg * &lt;optional&gt; this argument to use for &quot;this&quot; in the call of fn Source: Crio.js, line 701 Returns: the reduced value Type * &lt;inner&gt; reverse() get the same values, but in reverse order Source: Crio.js, line 1279 Returns: new crio array instance Type CrioArray &lt;inner&gt; set(key, value) set the value at the key passed Parameters: Name Type Description key number | string key to assign value to value * value to assign Source: Crio.js, line 723 Returns: new crio instance Type Crio &lt;inner&gt; setIn(keys, value) deeply set the value at the path passed Parameters: Name Type Description keys Array.&lt;(number|string)&gt; path to assign value to value * value to assign Source: Crio.js, line 742 Returns: new crio instance Type Crio &lt;inner&gt; shift() get crio based on current crio with first item removed Source: Crio.js, line 1296 Returns: new crio array instance Type CrioArray &lt;inner&gt; slice( [start] [, end]) get a new crio array based on a subset of the current crio Parameters: Name Type Argument Default Description start number &lt;optional&gt; 0 first index to include end number &lt;optional&gt; this.length size of array from first index Source: Crio.js, line 1311 Returns: new crio array instance Type CrioArray &lt;inner&gt; some(fn [, thisArg]) do any of the items in crio match per the fn passed Parameters: Name Type Argument Default Description fn function fn to iterate with thisArg * &lt;optional&gt; this argument to use as &quot;this&quot; in the iteration Source: Crio.js, line 765 Returns: are there any matches Type boolean &lt;inner&gt; sort(fn) sort the collection by the fn passed Parameters: Name Type Description fn function the function to sort based on Source: Crio.js, line 1333 Returns: new crio array instance Type CrioArray &lt;inner&gt; splice( [start] [, deleteCount], items) splice the values into or out of the array Parameters: Name Type Argument Default Description start number &lt;optional&gt; 0 starting index to splice deleteCount number &lt;optional&gt; 1 length from starting index to removes items Array.&lt;*&gt; &lt;repeatable&gt; items to insert after delete is complete Source: Crio.js, line 1351 Returns: new crio array instance Type CrioArray &lt;inner&gt; thaw() create a plain JS version of the crio Source: Crio.js, line 784 Returns: plain JS version of crio Type Array.&lt;*&gt; | Object &lt;inner&gt; toArray() convert the crio to an array if it isnt already Source: Crio.js, line 803 Returns: new crio array instance Type CrioArray &lt;inner&gt; toLocaleString() convert the crio to stringified form Source: Crio.js, line 822 Returns: stringified crio Type string &lt;inner&gt; toLocaleString() convert the crio to stringified form Source: Crio.js, line 862 Returns: stringified crio Type string &lt;inner&gt; toObject() convert the crio to an object if it isnt already Source: Crio.js, line 837 Returns: new crio object instance Type CrioObject &lt;inner&gt; unique() return the current CrioArray with the duplicate values removed Source: Crio.js, line 1380 Returns: new crio instance Type CrioArray &lt;inner&gt; unshift(items) add items passed to the beginning of the crio array Parameters: Name Type Argument Description items Array.&lt;*&gt; &lt;repeatable&gt; items to prepend to the array Source: Crio.js, line 1415 Returns: new crio array instance Type CrioArray &lt;inner&gt; valueOf() noop for valueOf Source: Crio.js, line 877 Returns: the same crio instance Type Crio &lt;inner&gt; values() get the values of the crio as an array Source: Crio.js, line 892 Returns: values in the crio Type Array.&lt;*&gt; &lt;inner&gt; xor(arrays) find the values that are the symmetric difference of this and the arrays passed Parameters: Name Type Description arrays Array.&lt;Array&gt; arrays to find symmetric values in Source: Crio.js, line 1439 Returns: new crio array instance Type CrioArray × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-crio_.html":{"id":"module-crio_.html","title":"Module: crio","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Module: crio Source: index.js, line 21 Methods &lt;inner&gt; crio( [object]) build a new crio object based on the object passed Parameters: Name Type Argument Default Description object * &lt;optional&gt; {} object to convert to crio Source: index.js, line 25 Returns: object that has been crioed Type CrioArray | CrioObject × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-Crio.Crio.html":{"id":"module-Crio.Crio.html","title":"Class: Crio","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Class: Crio Crio. Crio base crio class new Crio() Source: Crio.js, line 135 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-Crio.CrioArray.html":{"id":"module-Crio.CrioArray.html","title":"Class: CrioArray","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Class: CrioArray Crio. CrioArray extension of Crio class specific to arrays new CrioArray() Source: Crio.js, line 928 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-Crio.CrioObject.html":{"id":"module-Crio.CrioObject.html","title":"Class: CrioObject","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Class: CrioObject Crio. CrioObject extension of Crio class specific to objects new CrioObject() Source: Crio.js, line 1503 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-API.html":{"id":"tutorial-API.html","title":"Tutorial: API","body":" crio Modules Criocrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API API crio API Instantiation crio {any}, returns CrioArray|CrioObject Standard method, will crio the object passed if an array or object, else it will return the object itself crio.array {Array&lt;any&gt;}, returns CrioArray Shortcut method for crioing array-specific values crio.object {Object}, returns CrioObject Shortcut method for crioing object-specific values crio.isCrio {any}, returns boolean Determine if the object passed is a Crio crio.isArray {any}, returns boolean Determine if the object passed is a CrioArray crio.isObject {any}, returns boolean Determine if the object passed is a CrioObject Methods with the same name as the native method will be a link to MDN, as they are meant to be as similar to the native method as possible. Where any specific differences from the default behavior exist, they will be called out, however one broad difference is that all methods that are not getters which return primitive values are chainable. Shared Methods The following methods are specific to Crio types, and are available on either CrioArray or CrioObject clear, returns {CrioArray|CrioObject} returns an empty Crio compact, returns {CrioArray|CrioObject} returns a new Crio with all falsy values filtered out delete {number} key, returns {CrioArray|CrioObject} Deletes the key provided from the crio object deleteIn {Array&lt;number|string&gt;} keys, returns {CrioArray|CrioObject} Deletes the final key based on the array of keys nested inside of the crio object equals {CrioArray|CrioObject} crioArrayToCompare, returns {boolean} Determines whether array is deeply equal in value to another by comparing hashCodes get {number} key, returns {any} Retrieve value at key getIn {Array&lt;number|string&gt;} keys, returns {any} Retrieve value in deeply nested object based on array of keys has {string} key, returns {boolean} Alias for hasOwnProperty hasIn {Array&lt;number|string&gt;} keys, returns {boolean} Does the Crio have the combination of keys assigned deeply merge {Object[, Object2, ..., ObjectN]} objects, returns {CrioArray|CrioObject} Shallow merge any number of items into existing crio mergeIn {Array&lt;number|string&gt;} keys, {Object[, Object2, ..., ObjectN]} objects, returns {CrioArray|CrioObject} Shallow merge any number of items into value existing in deeply nested object based on array of keys mutate {function(mutableCrio, originalCrio): any} callback, returns {CrioArray|CrioObject} Whatever you return in the callback is what is returned, or if you return nothing it returns the original Crio pluck {number|string} key, returns {CrioArray|CrioObject} Iterates over Crio and returns an array of values where the key exists as a property on the collection item pluckIn {Array&lt;number|string} keys, returns {CrioArray|CrioObject} Iterates over Crio and returns an array of values where the keys map to a deeply-nested property on the collection item set {number} key, returns {CrioArray|CrioObject} Sets value at key setIn {Array&lt;number|string&gt;} keys, returns {CrioArray|CrioObject} Sets value in deeply nested object based on array of keys toArray, returns {CrioArray} Converts CrioObject to a CrioArray of the object's values toObject, returns {CrioObject} Converts CrioArray into a CrioObject of index: value pairs thaw, returns {Array&lt;any&gt;} Recursively thaws array deeply and returns standard object version of itself Arrays Default Methods concat copyWithin entries every fill Returns new crio with items from start to end filled with value filter find findIndex forEach includes Does a deep value equality comparison (rather than strict equality), so you can do things like crioArray.includes({foo: 'bar'}) indexOf join keys lastIndexOf map pop Returns new crio with first item removed push Returns new crio with new item added reduce reduceRight reverse shift Returns new crio with last item removed slice some sort Returns new crio sorted by either callback or default splice Returns new crio with items added/removed based on splicing parameters toLocaleString toString unshift Returns new crio with new items added to beginning values Added crio Methods difference {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that only exist in either the CrioArray or in one of the arrays passed findLastIndex {function} fn, returns {number} Same as findIndex but starting from end and working to start first {number} num, returns {CrioArray} Returns a new array of the first num number of items in the array intersection {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that exist in all of the arrays passed last {number} num, returns {CrioArray} Returns a new array of the last num number of items in the array unique, returns {CrioArray} Returns a new CrioArray of values filtered down to only existing in the array once xor {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that are the symmetric difference of the CrioArray and the arrays passed Objects Default Methods hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf Added crio Methods entries, returns {Array&lt;[string, any]&gt;} Gets an array of the [key, value] pairs in the CrioObject every {function(value, key, CrioObject): any} fn, {any} thisArg, returns {any} Performs same function as every in the Array prototype, but on the CrioObject forEach {function} fn, {any} thisArg, returns {CrioObject} Iterates over object executing fn Iteration order is not guaranteed filter {function} fn, {any} thisArg, returns {CrioObject} Iterates over object and filters out any returned values that are falsy Iteration order is not guaranteed findKey {function} fn, returns {number} Same as findIndex for CrioArray but finding the key instead of the index findLastKey {function} fn, returns {number} Same as findKey but starting from end and working to start includes {any} value, returns {boolean} Determine if the CrioObject has a value that deeply matches value in equality keys, returns {Array&lt;string&gt;} Returns an array of the keys in the CrioObject map {function} fn, {any} thisArg, returns {CrioObject} Iterates over object and maps returned value to the respective key Iteration order is not guaranteed reduce {function(accumulatedObject, value, key): any} fn, {any} thisArg, returns {any} Performs same function as reduce in the Array prototype, but on the CrioObject reduceRight {function(accumulatedObject, value, key): any} fn, {any} thisArg, returns {any} Performs same function as reduceRight in the Array prototype, but on the CrioObject some {function(value, key, CrioObject): any} fn, {any} thisArg, returns {any} Performs same function as some in the Array prototype, but on the CrioObject values, returns {Array&lt;any&gt;} Returns an array of the values in the CrioObject × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>

<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"constants.js.html":{"id":"constants.js.html","title":"Source: constants.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: constants.js // utils import {every, find, some} from './utils'; /** * @constant {Object} ARRAY_UNSCOPABLES */ export const ARRAY_UNSCOPABLES = { copyWithin: true, entries: true, fill: true, find: true, findIndex: true, findLastIndex: true, includes: true, keys: true, values: true }; /** * @constant {Object} ARRAY_FALLBACK_PROTOTYPE_METHODS */ export const ARRAY_FALLBACK_PROTOTYPE_METHODS = { /** * @function every * * @description * does every instance in the array match * * @param {function} fn the function to test for matching * @returns {boolean} does every instance match */ every(fn) { return every(this, fn); }, /** * @function find * * @description * find an item in the array if it exists * * @param {function} fn function to test for finding the item * @param {number} [fromIndex] key to start from when performing the find * @returns {*} found item or undefined */ find(fn, fromIndex) { return find(this, fn, fromIndex); }, /** * @function findIndex * * @description * find the index of an item in the array if it exists * * @param {function} fn function to test for finding the item * @param {number} [fromIndex] key to start from when performing the find * @returns {number} index of match, or -1 */ findIndex(fn, fromIndex) { return find(this, fn, fromIndex, true); }, /** * @function includes * * @description * does the array have the item passed * * @param {*} item item to test for existence * @returns {boolean} does the item exist in the array */ includes(item) { return !!~this.indexOf(item); }, /** * @function some * * @description * does any item in the array match the result from fn * * @param {function} fn the function to test for matching * @returns {boolean} does any item match */ some(fn) { return some(this, fn); } }; /** * @constant {Object} ARRAY_UNSCOPABLES */ export const OBJECT_UNSCOPABLES = { entries: true, fill: true, find: true, findKey: true, findLastKey: true, includes: true, keys: true, values: true }; /** * @constant {Symbol|number} */ export const REACT_ELEMENT_TYPE = typeof Symbol === 'function' &amp;&amp; Symbol.for ? Symbol.for('react.element') : 0xeac7; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"CrioArray.js.html":{"id":"CrioArray.js.html","title":"Source: CrioArray.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: CrioArray.js // external dependencies import stringify from 'json-stringify-safe'; import hashIt from 'hash-it'; import {parse} from 'pathington'; import {get, has, merge, remove, set} from 'unchanged'; // classes import CrioObject from './CrioObject'; // constants import {ARRAY_FALLBACK_PROTOTYPE_METHODS, ARRAY_UNSCOPABLES} from './constants'; // is import {isArray, isCrio, isEqual, isUndefined} from './is'; // utils import { createIterator, find, getCrioedObject, getEntries, getRelativeValue, getValues, thaw } from './utils'; let hasAppliedPrototype = false; class CrioArray extends Array { constructor(array) { super(isArray(array) ? array.length : array || 0); if (!hasAppliedPrototype) { applyPrototype(); hasAppliedPrototype = true; } if (isCrio(array)) { return array.toArray(); } return isArray(array) ? array.reduce((crioArray, item, index) =&gt; { crioArray[index] = getCrioedObject(item); return crioArray; }, this) : this; } get hashCode() { return hashIt(this, true); } /** * @function clear * @memberof CrioArray *folder * @description * get a new empty array * * @returns {CrioArray} the empty array */ clear() { return new CrioArray(); } /** * @function compact * @memberof CrioArray * * @description * get a new array with values from the original array that are truthy * * @returns {CrioArray} the array with only truthy values */ compact() { return this.filter((item) =&gt; { return !!item; }); } /** * @function copyWithin * * @description * move values around within the array * * @param {number} targetIndex target to copy * @param {number} [startIndex=0] index to start copying to * @param {number} [endIndex=this.length] index to stop copying to * @returns {CrioArray} array with target copied in appropriate spots */ copyWithin(targetIndex, startIndex = 0, endIndex = this.length) { const clone = [...this]; const length = this.length &gt;&gt;&gt; 0; let to = getRelativeValue(targetIndex &gt;&gt; 0, length), from = getRelativeValue(startIndex &gt;&gt; 0, length); const final = getRelativeValue(endIndex &gt;&gt; 0, length); let count = Math.min(final - from, length - to), direction = 1; if (from &lt; to &amp;&amp; to &lt; from + count) { direction = -1; from += count - 1; to += count - 1; } while (count &gt; 0) { if (from in clone) { clone[to] = clone[from]; } else { delete clone[to]; } from += direction; to += direction; count--; } return new this.constructor(clone); } /** * @function delete * @memberof CrioArray * * @description * delete the value in the array at key, either shallow or deep * * @param {Array&lt;number|string&gt;|number} key the key to delete * @returns {CrioArray} the array with the key deleted */ delete(key) { return remove(key, this); } /** * @function difference * @memberof CrioArray * * @description * find the values in this that do not exist in any of the arrays passed * * @param {...Array&lt;Array&lt;*&gt;&gt;} arrays arrays to get the difference of * @returns {CrioArray} array of items matching diffference criteria */ difference(...arrays) { if (!arrays.length) { return this; } let indexOfItem; return arrays.reduce((differenceArray, array) =&gt; { if (isArray(array)) { array.forEach((item) =&gt; { indexOfItem = differenceArray.indexOf(item); if (~indexOfItem) { differenceArray = differenceArray.splice(indexOfItem, 1); } }); } return differenceArray; }, this); } /** * @function entries * @memberof CrioArray * * @description * get the pairs of [key, value] in the crio * * @returns {CrioArray} [key, value] pairs */ entries() { return getEntries(this); } /** * @function equals * @memberof CrioArray * * @description * does the object passed equal the crio * * @param {*} object object to compare against the instance * @returns {boolean} is the object equivalent in value */ equals(object) { return isEqual(this, object); } /** * @function fill * * @description * fill the array at certain indices with the value passed * * @param {*} value the value to fill the indices with * @param {number} [startIndex=0] the starting index to fill * @param {number} [endIndex=this.length] the ending index to fill * @returns {CrioArray} array with values filled appropriately */ fill(value, startIndex = 0, endIndex = this.length) { const from = startIndex &lt; 0 ? this.length + startIndex : startIndex; const to = endIndex &lt; 0 ? this.length + endIndex : endIndex; const crioedValue = getCrioedObject(value); return this.map((item, index) =&gt; { return index &gt;= from &amp;&amp; index &lt; to ? crioedValue : item; }); } /** * @function findLast * @memberof CrioArray * * @description * find an item in the crio if it exists, starting from the end and iteratng to the start * * @param {function} fn function to test for finding the item * @param {number} [fromIndex] key to start from when performing the find * @returns {*} found item or undefined */ findLast(fn, fromIndex) { return find(this, fn, fromIndex, false, true); } /** * @function findLastIndex * @memberof CrioArray * * @description * find the matching index based on truthy return from fn starting from end * * @param {function} fn function to use for test in iteration * @param {number} [fromIndex] key to start from when performing the find * @returns {number} index of match, or -1 */ findLastIndex(fn, fromIndex) { return find(this, fn, fromIndex, true, true); } /** * @function first * @memberof CrioArray * * @description * take the first n number of items in the array * * @param {number} [size=1] size of elements to take from beginning of array * @returns {CrioArray} */ first(size = 1) { return this.slice(0, size); } /** * @function forEach * @memberof CrioArray * * @description * iterate over the array executing fn * * @param {function} fn the function to execute * @returns {CrioArray} the original array */ forEach(fn) { Array.prototype.forEach.call(this, fn); return this; } /** * @function get * @memberof CrioArray * * @description * get the item at key passed, either shallow or deeply nested * * @param {Array&lt;number|string&gt;|number} key key to retrieve * @returns {*} item found at key */ get(key) { return get(key, this); } /** * @function has * @memberof CrioArray * * @description * does the crio have the key passed, either shallow or deeply nested * * @param {Array&lt;number|string&gt;|number} key key to test * @returns {boolean} does the crio have the key */ has(key) { return has(key, this); } /** * @function intersection * @memberof CrioArray * * @description * find the values in that exist in this and each of the arrays passed * * @param {...Array&lt;Array&gt;} arrays to find the intersecting values of * @returns {CrioArray} array of values that exist in all arrays */ intersection(...arrays) { if (!arrays.length) { return this; } let indices = [], indexOfItem; const reducedArrays = [this, ...arrays].reduce((items, array) =&gt; { if (isArray(array)) { array.forEach((item) =&gt; { indexOfItem = items.indexOf(item); if (~indexOfItem) { return indices[indexOfItem]++; } indices[items.length] = 1; items.push(item); }); } return items; }, []); const newLength = arrays.length + 1; return new CrioArray( reducedArrays.filter((itemIgnored, index) =&gt; { return indices[index] === newLength; }) ); } /** * @function isArray * @memberof CrioArray * * @description * is the crio an array * * @returns {boolean} is the crio an array */ isArray() { return true; } /** * @function isObject * @memberof CrioArray * * @description * is the crio an object * * @returns {boolean} is the crio an object */ isObject() { return false; } /** * @function join * @memberof CrioArray * * @description * join the values in the crio as a string, combined with separator * * @param {string} [separator] character(s) to place between strings in combination * @returns {string} parameters joined by separator in string */ join(separator) { return this.thaw().join(separator); } /** * @function keys * @memberof CrioArray * * @description * get the keys of the crio * * @returns {CrioArray&lt;number&gt;} keys in the crio */ keys() { return new CrioArray(Object.keys(this).map(Number)); } /** * @function last * @memberof CrioArray * * @description * take the last n number of items in the array * * @param {number} [size=1] size of elements to take from end of array * @returns {CrioArray} */ last(size = 1) { return this.slice(this.length - size); } /** * @function map * @memberof CrioArray * * @description * map over the array returning the mapped items * * @param {function} fn the function to map * @returns {CrioArray} the mapped array */ map(fn) { return Array.prototype.map.call(this, (item, index) =&gt; { return getCrioedObject(fn(item, index, this)); }); } /** * @function merge * @memberof CrioArray * * @description * merge arrays with the original array * * @param {Array&lt;number|string&gt;|number|null} key the key to merge into * @param {...Array&lt;CrioArray&gt;} objects objects to merge with the crio * @returns {CrioArray} merged array */ merge(key, ...objects) { return objects.reduce((mergedObject, object) =&gt; { return merge(key, getCrioedObject(object), mergedObject); }, this); } /** * @function mutate * @memberof CrioArray * * @description * work with the array in a mutated way and return the crioed result of that call * * @param {function} fn function to apply to crio * @returns {*} crioed value resulting from the call */ mutate(fn) { return getCrioedObject(fn(this.thaw(), this)); } /** * @function pluck * @memberof CrioArray * * @description * get the values in each object in the collection at key, either shallow or deeply nested * * @param {string} key key to find value of in collection object * @returns {CrioArray} array of plucked values */ pluck(key) { const parsedKey = parse(key); const arrayToPluck = get(parsedKey.slice(0, parsedKey.length - 1), this); const finalKey = parsedKey.slice(-1); return arrayToPluck.map((item) =&gt; { return get(finalKey, item); }); } /** * @function pop * @memberof CrioArray * * @description * get crio based on current crio with last item removed * * @returns {CrioArray} array with the last value removed */ pop() { return this.slice(0, this.length - 1); } /** * @function push * @memberof CrioArray * * @description * push one to many items to the current crio * * @param {...Array&lt;*&gt;} items the items to add to the array * @returns {CrioArray} array with the values added */ push(...items) { return items.length ? this.concat(items) : this; } /** * @function reduce * @memberof CrioObject * * @description * reduce the crio down to a single value, starting with initial value * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @returns {*} the reduced value */ reduce(fn, initialValue) { return getCrioedObject( Array.prototype.reduce.call( this, (value, item, index) =&gt; { return fn(value, item, index, this); }, initialValue ) ); } /** * @function reduceRight * @memberof CrioObject * * @description * reduce the crio down to a single value, starting with initial value, starting from the end of the array * and iterating to the start * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @returns {*} the reduced value */ reduceRight(fn, initialValue) { return getCrioedObject( Array.prototype.reduceRight.call( this, (value, item, index) =&gt; { return fn(value, item, index, this); }, initialValue ) ); } /** * @function reverse * @memberof CrioArray * * @description * get the same values, but in reverse order * * @returns {CrioArray} array with the items reversed in order */ reverse() { return new CrioArray([...this].reverse()); } /** * @function set * @memberof CrioArray * * @description * set the value at the key passed * * @param {Array&lt;number|string&gt;|number} key key to assign value to * @param {*} value value to assign * @returns {CrioArray} array with value set at key */ set(key, value) { return set(key, getCrioedObject(value), this); } /** * @function shift * @memberof CrioArray * * @description * get crio based on current crio with first item removed * * @returns {CrioArray} array with the first item removed */ shift() { return this.slice(1); } /** * @function sort * @memberof CrioArray * * @description * sort the collection by the fn passed * * @param {function} fn the function to sort based on * @returns {CrioArray} array with the items sorted */ sort(fn) { const clone = [...this]; clone.sort(fn); return new CrioArray(clone); } /** * @function splice * @memberof CrioArray * * @description * splice the values into or out of the array * * @param {number} [start=0] starting index to splice * @param {number} [deleteCount=1] length from starting index to removes * @param {...Array&lt;*&gt;} items items to insert after delete is complete * @returns {CrioArray} array with the value spliced in / out */ splice(...args) { const clone = [...this]; clone.splice(...args); return new CrioArray(clone); } /** * @function thaw * @memberof CrioArray * * @description * create a plain JS version of the array * * @returns {Array&lt;*&gt;} plain JS version of the array */ thaw() { return thaw(this); } /** * @function toArray * @memberof CrioArray * * @description * convert the array to an array * * @returns {CrioArray} the array */ toArray() { return this; } /** * @function toLocaleString * @memberof CrioArray * * @description * convert the array to stringified form * * @param {function} [serializer] the serialization method to use * @param {number} [indent] the number of spaces to indent the values * @returns {string} stringified array */ toLocaleString(serializer, indent) { return this.toString(serializer, indent); } /** * @function toObject * @memberof CrioArray * * @description * convert the crio to an object if it isn't already * * @returns {CrioObject} new object from the array */ toObject() { return this.reduce((object, item, index) =&gt; { object[index] = item; return object; }, new CrioObject({})); } /** * @function toString * @memberof CrioArray * * @description * convert the array to stringified form * * @param {function} [serializer] the serialization method to use * @param {number} [indent] the number of spaces to indent the values * @returns {string} stringified array */ toString(serializer, indent) { return stringify(this, serializer, indent); } /** * @function unique * @memberof CrioArray * * @description * return the current CrioArray with the duplicate values removed * * @returns {CrioArray} new crio instance */ unique() { let hashArray = [], newArray = [], hasHashCode = false, hashCode, storeValue; return this.filter((item) =&gt; { hashCode = item ? item.hashCode : undefined; hasHashCode = !isUndefined(hashCode); storeValue = !~newArray.indexOf(item) &amp;&amp; (!hasHashCode || !~hashArray.indexOf(hashCode)); if (storeValue) { newArray.push(item); if (hasHashCode) { hashArray.push(hashCode); } } return storeValue; }); } /** * @function unshift * @memberof CrioArray * * @description * add items passed to the beginning of the crio array * * @param {...Array&lt;*&gt;} items items to prepend to the array * @returns {CrioArray} array with the items prepended */ unshift(...items) { return items.length ? new CrioArray([...items, ...this]) : this; } /** * @function valueOf * @memberof CrioArray * * @description * get the array value * * @returns {CrioArray} the array */ valueOf() { return this; } /** * @function values * @memberof CrioArray * * @description * get the values of the array as an array * * @returns {CrioArray} values in the array */ values() { return getValues(this); } /** * @function xor * @memberof CrioArray * * @description * find the values that are the symmetric difference of this and the arrays passed * * @param {Array&lt;Array&gt;} arrays arrays to find symmetric values in * @returns {CrioArray} array of the symmetric differences of all the arrays */ xor(...arrays) { if (!arrays.length) { return this; } let indicesToRemove = [], indexOfItem; const reducedItems = [this, ...arrays].reduce((items, array) =&gt; { if (isArray(array)) { array.forEach((item) =&gt; { indexOfItem = items.indexOf(item); if (~indexOfItem) { indicesToRemove.push(indexOfItem); } else { items = items.push(item); } }); } return items; }, new CrioArray([])); return reducedItems.filter((itemIgnored, index) =&gt; { return !~indicesToRemove.indexOf(index); }); } } export function applyPrototype() { Object.keys(ARRAY_FALLBACK_PROTOTYPE_METHODS).forEach((key) =&gt; { if (typeof Array.prototype[key] !== 'function') { CrioArray.prototype[key] = function(...args) { return ARRAY_FALLBACK_PROTOTYPE_METHODS[key](this, ...args); }; } }); if (typeof Symbol === 'function') { if (Symbol.species) { Object.defineProperty(CrioArray, Symbol.species, { configurable: false, enumerable: false, get() { return CrioArray; } }); } if (Symbol.iterator) { Object.defineProperty(CrioArray.prototype, Symbol.iterator, { configurable: false, enumerable: false, value: createIterator(), writable: false }); } if (Symbol.unscopables) { Object.defineProperty(CrioArray.prototype, Symbol.unscopables, { configurable: false, enumerable: false, value: ARRAY_UNSCOPABLES, writable: false }); } } } export default CrioArray; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: utils.js // classes import CrioArray from './CrioArray'; import CrioObject from './CrioObject'; // is import { isArray, isCrio, isNumber, isObject, isReactElement, isString, isUndefined } from './is'; /** * @function createIterator * * @description * create a new iterator method * * @returns {function} the iterator method */ export const createIterator = () =&gt; { return function iterator() { const keys = this.keys(); const length = keys.length; let index = 0, value; return { next: () =&gt; { if (index &lt; length) { value = this[keys[index++]]; return { done: false, value }; } return { done: true }; } }; }; }; /** * @function every * * @description * does every result from calling fn match * * @param {CrioArray|CrioObject} object the object to test * @param {function} fn the function to perform the test on each item with * @returns {boolean} does every item match */ export const every = (object, fn) =&gt; { const objectKeys = object.keys(); let key; for (let index = 0; index &lt; objectKeys.length; index++) { key = objectKeys[index]; if (!fn(object[key], key, object)) { return false; } } return true; }; /** * @function getKeysReducedForFind * * @description * get the array of keys reduced for what is required for the find * * @param {Array&lt;number|string&gt;} allKeys the complete list of keys * @param {number|string} fromKey the key to start from * @returns {Array&lt;number|keys&gt;} the reduced set of keys */ export const getKeysReducedForFind = (allKeys, fromKey) =&gt; { if (isUndefined(fromKey)) { return allKeys; } if (isNumber(fromKey)) { return allKeys.slice(fromKey); } if (isString(fromKey)) { let matchFound = false; return allKeys.reduce((reducedKeys, key) =&gt; { matchFound = matchFound || key === fromKey; if (matchFound) { reducedKeys.push(key); } return reducedKeys; }, []); } return allKeys; }; /** * @function find * * @description * find an item in the array if it exists * * @param {CrioArray|CrioObject} object the object to search * @param {function} fn function to test for finding the item * @param {number} [fromKey] key to start from when performing the find * @param {boolean} [isKey] is the search for a key * @param {boolean} [isFromEnd] is the search for a key * @returns {*} found item or undefined */ export const find = (object, fn, fromKey, isKey, isFromEnd) =&gt; { const reducedKeys = getKeysReducedForFind(object.keys(), fromKey); const objectKeys = isFromEnd ? reducedKeys.reverse() : reducedKeys; let key; for (let index = 0; index &lt; objectKeys.length; index++) { key = objectKeys[index]; if (fn(object[key], key, object)) { return isKey ? key : object[key]; } } if (isKey) { return object.isArray() ? -1 : undefined; } return undefined; }; /** * @function getCrioedObject * * @description * get the object converted to a CrioArray or CrioObject, if applicable * * @param {*} object the object to potentially crio * @returns {*} either the crioed object, or the object itself */ export const getCrioedObject = (object) =&gt; { if (!object || typeof object !== 'object') { return object; } if (isArray(object)) { return object instanceof CrioArray ? object : new CrioArray(object); } return isObject(object) ? new CrioObject(object) : object; }; /** * @function getEntries * * @description * get the [key, value] pairs of the object * * @param {CrioArray|CrioObject} object the object to get the entries of * @returns {CrioArray} the entries of the object */ export const getEntries = (object) =&gt; { return object.keys().map((key) =&gt; { return [key, object[key]]; }); }; /** * @function getRelativeValue * * @description * get the relative value used in copyWithin * * @param {number} value value used as baseline * @param {number} length the length of the crio * @returns {number} the relative number value */ export const getRelativeValue = (value, length) =&gt; { return value &lt; 0 ? Math.max(length + value, 0) : Math.min(value, length); }; /** * @function getValues * * @description * get the values of the object * * @param {CrioArray|CrioObject} object the object to get the values of * @returns {CrioArray} the values of the object */ export const getValues = (object) =&gt; { return object.keys().map((key) =&gt; { return object[key]; }); }; /** * @function some * * @description * does any result from calling fn match * * @param {CrioArray|CrioObject} object the object to test * @param {function} fn the function to perform the test on each item with * @returns {boolean} does any item match */ export const some = (object, fn) =&gt; { const objectKeys = object.keys(); let key; for (let index = 0; index &lt; objectKeys.length; index++) { key = objectKeys[index]; if (fn(object[key], key, object)) { return true; } } return false; }; /** * @function thaw * * @description * convert the CrioArray or CrioObject passed to a plain JS object * * @param {CrioArray|CrioObject} object the object to convert * @returns {Array|Object} the plain JS version of the object passed */ export const thaw = (object) =&gt; { if (!isCrio(object)) { return object; } return object.isArray() ? [...object].map((item) =&gt; { return thaw(item); }) : Object.keys(object).reduce((reducedObject, key) =&gt; { reducedObject[key] = thaw(object[key]); return reducedObject; }, {}); }; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: index.js // classes import CrioArray from './CrioArray'; import CrioObject from './CrioObject'; // is import {isArray, isCrio, isObject} from './is'; /** * @module crio */ /** * @function crio * * @description * build a new crio object based on the object passed * * @param {*} [object={}] object to convert to crio * * @returns {CrioArray|CrioObject} object that has been crioed */ const crio = (object = {}) =&gt; { if (isCrio(object)) { return object; } if (isArray(object)) { return new CrioArray(object); } if (isObject(object)) { return new CrioObject(object); } throw new TypeError('Object passed must be either an array or a plain object.'); }; /** * @function crio.array * * @description * convenience method for making crio arrays * * @param {Array&lt;*&gt;} array array to crio * @returns {CrioArray} crio array */ crio.array = (array = []) =&gt; { if (!isArray(array)) { throw new TypeError('Object passed must be an array.'); } return crio(array); }; /** * @function crio.isArray * * @description * check if object is a crio array * * @param {*} object object to test * @returns {boolean} is the object a crio array */ crio.isArray = (object) =&gt; { return isCrio(object) &amp;&amp; object.isArray(); }; crio.isCrio = isCrio; /** * @function crio.isObject * * @description * check if object is a crio object * * @param {*} object object to test * @returns {boolean} is the object a crio object */ crio.isObject = (object) =&gt; { return isCrio(object) &amp;&amp; object.isObject(); }; /** * @function crio.object * * @description * convenience method for making crio objects * * @param {Object} object object to crio * @returns {CrioObject} crio object */ crio.object = (object = {}) =&gt; { if (!isObject(object)) { throw new TypeError('Object passed must be a plain object.'); } return crio(object); }; export default crio; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"CrioObject.js.html":{"id":"CrioObject.js.html","title":"Source: CrioObject.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: CrioObject.js // external dependencies import stringify from 'json-stringify-safe'; import {parse} from 'pathington'; import hashIt from 'hash-it'; import {get, has, merge, remove, set} from 'unchanged'; // classes import CrioArray from './CrioArray'; // constants import {OBJECT_UNSCOPABLES} from './constants'; // is import {isCrio, isEqual, isObject} from './is'; // utils import { createIterator, getCrioedObject, getEntries, getValues, every, find, some, thaw } from './utils'; let hasAppliedPrototype; class CrioObject { constructor(object) { const objectKeys = isObject(object) ? Object.keys(object) : []; if (!hasAppliedPrototype) { applyPrototype(); hasAppliedPrototype = true; } if (isCrio(object)) { return object.toObject(); } return objectKeys.reduce((crioObject, key) =&gt; { crioObject[key] = getCrioedObject(object[key]); return crioObject; }, this); } get hashCode() { return hashIt(this, true); } get size() { return Object.keys(this).length; } /** * @function clear * @memberof CrioObject * * @description * get a new crio that is empty * * @returns {CrioObject} an empty object */ clear() { return new CrioObject(); } /** * @function compact * @memberof CrioObject * * @description * get a new object with values from the original array that are truthy * * @returns {CrioObject} the object with only truthy values */ compact() { return this.filter((item) =&gt; { return !!item; }); } /** * @function delete * @memberof CrioObject * * @description * delete the value in the object at key, either shallow or deep * * @param {Array&lt;number|string&gt;|sring} key the key to delete * @returns {CrioObject} the array with the key deleted */ delete(key) { return remove(key, this); } /** * @function entries * @memberof CrioObject * * @description * get the pairs of [key, value] in the crio * * @returns {CrioArray} [key, value] pairs */ entries() { return getEntries(this); } /** * @function equals * @memberof CrioObject * * @description * does the object passed equal the crio * * @param {*} object object to compare against the instance * @returns {boolean} is the object equivalent in value */ equals(object) { return isEqual(this, object); } /** * @function every * @memberof CrioObject * * @description * does every instance in the object match * * @param {function} fn the function to test for matching * @returns {boolean} does every instance match */ every(fn) { return every(this, fn); } /** * @function filter * @memberof CrioObject * * @description * filter the object based on the fn passed * * @param {function} fn function to test for if it should be included in the result set * @returns {CrioObject} new crio instance */ filter(fn) { return new CrioObject( Object.keys(this).reduce((object, key) =&gt; { if (fn(this[key], key, object)) { object[key] = this[key]; } return object; }, {}) ); } /** * @function find * @memberof CrioObject * * @description * find an item in the crio if it exists * * @param {function} fn function to test for finding the item * @param {string} [fromKey] key to start from when performing the find * @returns {*} found item or undefined */ find(fn, fromKey) { return find(this, fn, fromKey); } /** * @function findKey * @memberof CrioObject * * @description * find the key of an item in the crio if it exists * * @param {function} fn function to test for finding the item * @param {number} [fromKey] key to start from when performing the find * @returns {number} index of match, or -1 */ findKey(fn, fromKey) { return find(this, fn, fromKey, true); } /** * @function findLast * @memberof CrioObject * * @description * find an item in the crio if it exists, starting from the end and iteratng to the start * * @param {function} fn function to test for finding the item * @param {number} [fromKey] key to start from when performing the find * @returns {*} found item or undefined */ findLast(fn, fromKey) { return find(this, fn, fromKey, false, true); } /** * @function findLastKey * @memberof CrioObject * * @description * find the matching index based on truthy return from fn starting from end * * @param {function} fn function to use for test in iteration * @param {number} [fromKey] key to start from when performing the find * @returns {number} index of match, or -1 */ findLastKey(fn, fromKey) { return find(this, fn, fromKey, true, true); } /** * @function forEach * @memberof CrioObject * * @description * iterate over the object calling fn * * @param {function} fn function to call in iteration * @returns {CrioObject} the original object */ forEach(fn) { Object.keys(this).forEach((key) =&gt; { fn(this[key], key, this); }); return this; } /** * @function get * @memberof CrioObject * * @description * get the item at key passed, either shallow or deeply nested * * @param {Array&lt;number|string&gt;|string} key key to retrieve * @returns {*} item found at key */ get(key) { return get(key, this); } /** * @function has * @memberof CrioObject * * @description * does the crio have the key passed, either shallow or deeply nested * * @param {Array&lt;number|string&gt;|string} key key to test * @returns {boolean} does the crio have the key */ has(key) { return has(key, this); } /** * @function includes * @memberof CrioObject * * @description * does the object have the item passed * * @param {*} item item to test for existence * @returns {boolean} does the item exist in the crio */ includes(item) { return this.some((value) =&gt; { return value === item; }); } /** * @function isArray * @memberof CrioObject * * @description * is the crio an array * * @returns {boolean} is the crio an array */ isArray() { return false; } /** * @function isObject * @memberof CrioObject * * @description * is the crio an object * * @returns {boolean} is the crio an object */ isObject() { return true; } /** * @function keyOf * @memberof CrioObject * * @description * get the key for the item passed * * @param {*} item the item to search for * @returns {string} the key of match, or undefined */ keyOf(item) { return this.findKey((value) =&gt; { return value === item; }); } /** * @function keys * @memberof CrioObject * * @description * get the keys of the crio * * @returns {CrioArray&lt;string&gt;} keys in the crio */ keys() { return new CrioArray(Object.keys(this)); } /** * @function lastKeyOf * @memberof CrioObject * * @description * get the key for the item passed, starting from the end of the array and iterating towards the start * * @param {*} item the item to search for * @returns {string} the key of match, or undefined */ lastKeyOf(item) { return this.findLastKey((value) =&gt; { return value === item; }); } /** * @function map * @memberof CrioObject * * @description * iterate over the object mapping the result of fn to the key * * @param {function} fn function to call on iteration * @returns {Crio} the mapped object */ map(fn) { return Object.keys(this).reduce((object, key) =&gt; { object[key] = getCrioedObject(fn(this[key], key, this)); return object; }, new CrioObject({})); } /** * @function merge * @memberof CrioObject * * @description * merge objects with the original object * * @param {Array&lt;number|string&gt;|number|null} key the key to merge into * @param {...Array&lt;CrioObject&gt;} objects objects to merge with the crio * @returns {CrioObject} new crio instance */ merge(key, ...objects) { return objects.reduce((mergedObject, object) =&gt; { return merge(key, getCrioedObject(object), mergedObject); }, this); } /** * @function mutate * @memberof CrioObject * * @description * work with the object in a mutated way and return the crioed result of that call * * @param {function} fn function to apply to crio * @returns {*} crioed value resulting from the call */ mutate(fn) { return getCrioedObject(fn(this.thaw(), this)); } /** * @function pluck * @memberof CrioObject * * @description * get the values in each object in the collection at key, either shallow or deeply nested * * @param {string} key key to find value of in collection object * @returns {CrioArray} array of plucked values */ pluck(key) { const parsedKey = parse(key); const objectToPluck = get(parsedKey.slice(0, parsedKey.length - 1), this); const finalKey = parsedKey.slice(-1); return objectToPluck .map((item) =&gt; { return get(finalKey, item); }) .values(); } /** * @function reduce * @memberof CrioObject * * @description * reduce the crio down to a single value, starting with initial value * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @returns {*} the reduced value */ reduce(fn, initialValue) { return getCrioedObject( Object.keys(this).reduce((value, key) =&gt; { return fn(value, this[key], key, this); }, initialValue) ); } /** * @function reduceRight * @memberof CrioObject * * @description * reduce the crio down to a single value, starting with initial value, starting from the end of the array * and iterating to the start * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @returns {*} the reduced value */ reduceRight(fn, initialValue) { return getCrioedObject( Object.keys(this) .reverse() .reduce((value, key) =&gt; { return fn(value, this[key], key, this); }, initialValue) ); } /** * @function set * @memberof CrioObject * * @description * set the value at the key passed * * @param {Array&lt;number|string&gt;|string} key key to assign value to * @param {*} value value to assign * @returns {CrioObject} object with value set at key */ set(key, value) { return set(key, getCrioedObject(value), this); } /** * @function some * @memberof CrioObject * * @description * does any item in the object match the result from fn * * @param {function} fn the function to test for matching * @returns {boolean} does any item match */ some(fn) { return some(this, fn); } /** * @function sort * @memberof CrioObject * * @description * sort the collection by the fn passed * * @param {function} fn the function to sort based on * @returns {CrioObject} object with the items sorted */ sort(fn) { return new CrioObject( Object.keys(this) .sort(fn) .reduce((object, key) =&gt; { object[key] = this[key]; return object; }, {}) ); } /** * @function thaw * @memberof CrioObject * * @description * create a plain JS version of the object * * @returns {Object} plain JS version of the object */ thaw() { return thaw(this); } /** * @function toArray * @memberof CrioObject * * @description * convert the object to an array * * @returns {CrioArray} the object converted to an array of its values */ toArray() { return this.values(); } /** * @function toLocaleString * @memberof CrioObject * * @description * convert the object to stringified form * * @param {function} [serializer] the serialization method to use * @param {number} [indent] the number of spaces to indent the values * @returns {string} stringified object */ toLocaleString(serializer, indent) { return this.toString(serializer, indent); } /** * @function toObject * @memberof CrioObject * * @description * convert the object to an objectobject * * @returns {CrioObject} the object */ toObject() { return this; } /** * @function toString * @memberof CrioObject * * @description * convert the object to stringified form * * @param {function} [serializer] the serialization method to use * @param {number} [indent] the number of spaces to indent the values * @returns {string} stringified object */ toString(serializer, indent) { return stringify(this, serializer, indent); } /** * @function valueOf * @memberof CrioObject * * @description * get the object value * * @returns {CrioObject} the object */ valueOf() { return this; } /** * @function values * @memberof CrioObject * * @description * get the values of the object as an array * * @returns {CrioObject} values in the object */ values() { return getValues(this); } } export function applyPrototype() { if (typeof Symbol === 'function') { if (Symbol.species) { Object.defineProperty(CrioObject, Symbol.species, { configurable: false, enumerable: false, get() { return CrioObject; } }); } if (Symbol.iterator) { Object.defineProperty(CrioObject.prototype, Symbol.iterator, { configurable: false, enumerable: false, value: createIterator(), writable: false }); } if (Symbol.unscopables) { Object.defineProperty(CrioObject.prototype, Symbol.unscopables, { configurable: false, enumerable: false, value: OBJECT_UNSCOPABLES, writable: false }); } } } export default CrioObject; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"is.js.html":{"id":"is.js.html","title":"Source: is.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: is.js // classes import CrioArray from './CrioArray'; import CrioObject from './CrioObject'; // constants import {REACT_ELEMENT_TYPE} from './constants'; /** * @function isArray * * @description * is the object passed an array * * @param {*} object the object to test * @returns {boolean} is the object an array */ export const isArray = Array.isArray; /** * @function isCrio * * @description * is the object passed a CrioArray or CrioObject * * @param {*} object the object to test * @returns {boolean} is the object a Crio* */ export const isCrio = (object) =&gt; { return object instanceof CrioArray || object instanceof CrioObject; }; /** * @function isEqual * * @description * are the crio objects equal * * @param {CrioArray|CrioObject} crio crio object to test against * @param {*} object object to test equality with crio object for * @returns {boolean} are the objects equal */ export const isEqual = (crio, object) =&gt; { return isCrio(object) &amp;&amp; crio.hashCode === object.hashCode; }; /** * @function isFunction * * @description * is the object passed a function * * @param {*} object the object to test * @returns {boolean} is the object a function */ export const isFunction = (object) =&gt; { return typeof object === 'function'; }; /** * @function isNumber * * @description * is the object passed a number * * @param {*} object the object to test * @returns {boolean} is the object a number */ export const isNumber = (object) =&gt; { return typeof object === 'number'; }; /** * @function isReactElement * * @description * is the object passed a react element * * @param {*} object the object to test * @returns {boolean} is the object a react element */ export const isReactElement = (object) =&gt; { return !!object &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE; }; /** * @function isObject * * @description * is the object passed a plain object * * @param {*} object the object to test * @returns {boolean} is the object a plain object */ export const isObject = (object) =&gt; { return !!object &amp;&amp; object.constructor === Object &amp;&amp; !isReactElement(object); }; /** * @function isString * * @description * is the object passed a string * * @param {*} object the object to test * @returns {boolean} is the object a string */ export const isString = (object) =&gt; { return typeof object === 'string'; }; /** * @function isUndefined * * @description * is the object passed undefined * * @param {*} object the object to test * @returns {boolean} is the object undefined */ export const isUndefined = (object) =&gt; { return object === void 0; }; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Global Members &lt;constant&gt; ARRAY_FALLBACK_PROTOTYPE_METHODS :Object Type: Object Source: constants.js, line 23 &lt;constant&gt; ARRAY_UNSCOPABLES :Object Type: Object Source: constants.js, line 8 &lt;constant&gt; ARRAY_UNSCOPABLES :Object Type: Object Source: constants.js, line 100 &lt;constant&gt; REACT_ELEMENT_TYPE :Symbol|number Type: Symbol | number Source: constants.js, line 117 Methods copyWithin(targetIndex [, startIndex] [, endIndex]) move values around within the array Parameters: Name Type Argument Default Description targetIndex number target to copy startIndex number &lt;optional&gt; 0 index to start copying to endIndex number &lt;optional&gt; this.length index to stop copying to Source: CrioArray.js, line 138 Returns: array with target copied in appropriate spots Type CrioArray createIterator() create a new iterator method Source: utils.js, line 24 Returns: the iterator method Type function every(object, fn) does every result from calling fn match Parameters: Name Type Description object CrioArray | CrioObject the object to test fn function the function to perform the test on each item with Source: utils.js, line 61 Returns: does every item match Type boolean every(fn) does every instance in the array match Parameters: Name Type Description fn function the function to test for matching Source: constants.js, line 28 Returns: does every instance match Type boolean fill(value [, startIndex] [, endIndex]) fill the array at certain indices with the value passed Parameters: Name Type Argument Default Description value * the value to fill the indices with startIndex number &lt;optional&gt; 0 the starting index to fill endIndex number &lt;optional&gt; this.length the ending index to fill Source: CrioArray.js, line 272 Returns: array with values filled appropriately Type CrioArray find(object, fn [, fromKey] [, isKey] [, isFromEnd]) find an item in the array if it exists Parameters: Name Type Argument Description object CrioArray | CrioObject the object to search fn function function to test for finding the item fromKey number &lt;optional&gt; key to start from when performing the find isKey boolean &lt;optional&gt; is the search for a key isFromEnd boolean &lt;optional&gt; is the search for a key Source: utils.js, line 123 Returns: found item or undefined Type * find(fn [, fromIndex]) find an item in the array if it exists Parameters: Name Type Argument Description fn function function to test for finding the item fromIndex number &lt;optional&gt; key to start from when performing the find Source: constants.js, line 42 Returns: found item or undefined Type * findIndex(fn [, fromIndex]) find the index of an item in the array if it exists Parameters: Name Type Argument Description fn function function to test for finding the item fromIndex number &lt;optional&gt; key to start from when performing the find Source: constants.js, line 57 Returns: index of match, or -1 Type number getCrioedObject(object) get the object converted to a CrioArray or CrioObject, if applicable Parameters: Name Type Description object * the object to potentially crio Source: utils.js, line 157 Returns: either the crioed object, or the object itself Type * getEntries(object) get the [key, value] pairs of the object Parameters: Name Type Description object CrioArray | CrioObject the object to get the entries of Source: utils.js, line 178 Returns: the entries of the object Type CrioArray getKeysReducedForFind(allKeys, fromKey) get the array of keys reduced for what is required for the find Parameters: Name Type Description allKeys Array.&lt;(number|string)&gt; the complete list of keys fromKey number | string the key to start from Source: utils.js, line 87 Returns: the reduced set of keys Type Array.&lt;(number|keys)&gt; getRelativeValue(value, length) get the relative value used in copyWithin Parameters: Name Type Description value number value used as baseline length number the length of the crio Source: utils.js, line 193 Returns: the relative number value Type number getValues(object) get the values of the object Parameters: Name Type Description object CrioArray | CrioObject the object to get the values of Source: utils.js, line 207 Returns: the values of the object Type CrioArray includes(item) does the array have the item passed Parameters: Name Type Description item * item to test for existence Source: constants.js, line 72 Returns: does the item exist in the array Type boolean isArray(object) is the object passed an array Parameters: Name Type Description object * the object to test Source: is.js, line 18 Returns: is the object an array Type boolean isCrio(object) is the object passed a CrioArray or CrioObject Parameters: Name Type Description object * the object to test Source: is.js, line 29 Returns: is the object a Crio* Type boolean isEqual(crio, object) are the crio objects equal Parameters: Name Type Description crio CrioArray | CrioObject crio object to test against object * object to test equality with crio object for Source: is.js, line 46 Returns: are the objects equal Type boolean isFunction(object) is the object passed a function Parameters: Name Type Description object * the object to test Source: is.js, line 60 Returns: is the object a function Type boolean isNumber(object) is the object passed a number Parameters: Name Type Description object * the object to test Source: is.js, line 73 Returns: is the object a number Type boolean isObject(object) is the object passed a plain object Parameters: Name Type Description object * the object to test Source: is.js, line 99 Returns: is the object a plain object Type boolean isReactElement(object) is the object passed a react element Parameters: Name Type Description object * the object to test Source: is.js, line 86 Returns: is the object a react element Type boolean isString(object) is the object passed a string Parameters: Name Type Description object * the object to test Source: is.js, line 112 Returns: is the object a string Type boolean isUndefined(object) is the object passed undefined Parameters: Name Type Description object * the object to test Source: is.js, line 125 Returns: is the object undefined Type boolean some(fn) does any item in the array match the result from fn Parameters: Name Type Description fn function the function to test for matching Source: constants.js, line 86 Returns: does any item match Type boolean some(object, fn) does any result from calling fn match Parameters: Name Type Description object CrioArray | CrioObject the object to test fn function the function to perform the test on each item with Source: utils.js, line 222 Returns: does any item match Type boolean thaw(object) convert the CrioArray or CrioObject passed to a plain JS object Parameters: Name Type Description object CrioArray | CrioObject the object to convert Source: utils.js, line 248 Returns: the plain JS version of the object passed Type Array | Object × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Modules × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Tutorials × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw crio 4.1.2 crio Immutable JS objects with a natural API Jump to the API API Documentation Upgrade notice If upgrading from 3.x.x versions, please check the changelog for breaking changes. Import into your project // ES2015 import crio from 'crio'; // CommonJS const crio = require('crio'); // UMD const crio = window.crio;Usage // you can assign with crio() directly const crioArray = crio(['foo']); const crioObject = crio({foo: 'bar'}); // or use the convenience methods const otherCrioArray = crio.array(['bar']); const otherCrioObject = crio.object({bar: 'baz'});What is immutable? When something is described as immutable, it means that it cannot change after it has been created. In JavaScript terms, this means that any attempted change to an object results in a brand new object being created, without changing the original object. Why do we need this in JavaScript? The concept of immutability already exists in a lot of places in JavaScript, for example: const two = 2; const three = 3; const five = two + three;By adding together two and three you expect to get five, however you don't expect the value of two to change. You can continue working with it even after using it in an expression: const two = 2; const three = 3; const five = two + three; const four = two * two;This is true of strings, numbers, undefined, and null, and is an expected behavior. The same idea, however, is not true for complex objects in JavaScript. For example: const foo = ['foo']; const fooBar = foo.push('bar');The expectation is that you have pushed the value of &quot;bar&quot; into foo and created a new array bar that contains &quot;foo, bar&quot;, however in reality this is what happens: const foo = ['foo']; const fooBar = foo.push('bar'); console.log(foo); // ['foo', 'bar'] console.log(fooBar); // 1Basically, you have mutated foo so that it is no longer empty, and what the .push() method returns is actually the index of the item you just added. This double-standard of expectations creates a lot confusion from a development perspective, but also makes keeping track of the state of your application very difficult because there is no traceability of what transactions have occurred to create that state at any given point. Enter crio crio attempts to solve the problem by closing the &quot;immutable loop&quot; on collection items, meaning it applies immutability to objects that are normally mutable by nature by replacing mutating methods with immutable counterparts. As a point of reference: Naturally immutable objects Numbers Strings undefined null Naturally mutable objects Arrays Dates (not covered by crio) Objects To create a new crio object, its pretty straightforward: const crioArray = crio([]); const crioObject = crio({}); // or just crio()These are examples with empty objects, but you can pass in populated objects as well, or if you pass in nothing it will default to an object. What crio does is clone and freeze the object via Object.freeze, and stores as a custom CrioArray or CrioObject with a prototypical methods that will return a new immutable version of the object with each update. Example: const foo = crio(['foo']); const fooBar = foo.push('bar'); console.log(foo); // ['foo'] console.log(fooBar); // ['foo', 'bar']The API is the same as you already know working with those objects, and includes polyfills for all ES6 and some ES7 functions, as well as a few helpful crio-specific functions. The only difference is that any setting happens via .set() rather than direct index / property setting. You can work with the objects as you normally would with other libraries (lodash, for example). There is also no change to the protoypes of native objects, so you can apply this on your existing code go-forward. Basically, you shouldn't even notice you aren't working with the native objects, save for the fact everything is immutable. Why not just use X immutable library? There are a bunch of ones out there, but the two that people usually gravitate towards: Immutable.js seamless-immutable immutable is quite nice, and very highly regarded by the community, however it creates an opaque object that cannot be used with other external libraries (namely lodash) without converting back to vanilla JS. Additionally, the object itself is not truly immutable, just constructed in a way that makes it incredibly difficult to alter outside of the API. This decision was likely made for performance reasons, but can cause unintended consequences (you can totally assign foo.bar = 'baz' and no error is thrown). seamless-immutable has some great ideas, and I thought that could be the best option because they try to retain the native operations while leveraging Object.freeze, much like crio does. That said, they do not try to replace mutable methods with immutable ones, they just throw errors when you attempt them and its up to you to figure out the &quot;right way&quot;. As such, it fell short of my expectations. Bottom line, I support each of these projects to the fullest because they are trying to instill immutability in JavaScript practices; I just took a different approach that I consider the best of both worlds. :) Browser support The only requirement is that your browser has a proper ES5 environment, which you can mostly shim with something like es5-shim, however certain things like Object.defineProperty cannot be shimmed, so IE8 and below cannot be supported. crio has been tested on the following browsers: Chrome Firefox Edge IE9 Performance As of 4.0.0, performance has substantially improved, and in many scenarios crio is more performant than seamless-immutable (in the case of setIn, by over 5x). When it comes to get operations (either directly or nested), crio is identical to native in performance. See the benchmark results if you want to see performance in node, or spin up the app locally if you want to see the performance in the browser. Gotchas Recursive objects are not allowed Immutable objects with recursive values are basically impossible, and trying them will cause a stack overflow, so be mindful of that! Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: benchmark =&gt; run benchmarks in node benchmark:watch =&gt; run benchmark with persistent watcher for changes build =&gt; run webpack to build crio.js with NODE_ENV=development build:minifed =&gt; run webpack to build crio.min.js with NODE_ENV=production compile-for-publish =&gt; run lint, test, transpile, dist dev =&gt; run webpack dev server to run example app (playground!) dev:production =&gt; runs dev but with NODE_ENV=production dist =&gt; runs build and build-minified lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish test =&gt; run AVA test functions with NODE_ENV=test test:watch =&gt; same as test, but runs persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-crio.html":{"id":"module-crio.html","title":"Module: crio","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Module: crio Source: index.js, line 17 Methods &lt;inner&gt; crio( [object]) build a new crio object based on the object passed Parameters: Name Type Argument Default Description object * &lt;optional&gt; {} object to convert to crio Source: index.js, line 21 Returns: object that has been crioed Type CrioArray | CrioObject × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"tutorial-API.html":{"id":"tutorial-API.html","title":"Tutorial: API","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetKeysReducedForFindgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw API crio API Instantiation crio {any}, returns CrioArray|CrioObject Standard method, will crio the object passed if an array or object, else it will return the object itself crio.array {Array&lt;any&gt;}, returns CrioArray Shortcut method for crioing array-specific values crio.object {Object}, returns CrioObject Shortcut method for crioing object-specific values crio.isCrio {any}, returns boolean Determine if the object passed is a Crio crio.isArray {any}, returns boolean Determine if the object passed is a CrioArray crio.isObject {any}, returns boolean Determine if the object passed is a CrioObject Methods with the same name as the native method will be a link to MDN, as they are meant to be as similar to the native method as possible. Where any specific differences from the default behavior exist, they will be called out, however one broad difference is that all methods that are not getters which return primitive values are chainable. Shared Methods The following methods are specific to Crio types, and are available on either CrioArray or CrioObject clear, returns {CrioArray|CrioObject} returns an empty Crio compact, returns {CrioArray|CrioObject} returns a new Crio with all falsy values filtered out delete {number} key, returns {CrioArray|CrioObject} Deletes the key provided from the crio object deleteIn {Array&lt;number|string&gt;} keys, returns {CrioArray|CrioObject} Deletes the final key based on the array of keys nested inside of the crio object equals {CrioArray|CrioObject} crioArrayToCompare, returns {boolean} Determines whether array is deeply equal in value to another by comparing hashCodes get {number} key, returns {any} Retrieve value at key getIn {Array&lt;number|string&gt;} keys, returns {any} Retrieve value in deeply nested object based on array of keys has {string} key, returns {boolean} Alias for hasOwnProperty hasIn {Array&lt;number|string&gt;} keys, returns {boolean} Does the Crio have the combination of keys assigned deeply merge {Object[, Object2, ..., ObjectN]} objects, returns {CrioArray|CrioObject} Shallow merge any number of items into existing crio mergeIn {Array&lt;number|string&gt;} keys, {Object[, Object2, ..., ObjectN]} objects, returns {CrioArray|CrioObject} Shallow merge any number of items into value existing in deeply nested object based on array of keys mutate {function(mutableCrio, originalCrio): any} callback, returns {CrioArray|CrioObject} Whatever you return in the callback is what is returned, or if you return nothing it returns the original Crio pluck {number|string} key, returns {CrioArray|CrioObject} Iterates over Crio and returns an array of values where the key exists as a property on the collection item pluckIn {Array&lt;number|string} keys, returns {CrioArray|CrioObject} Iterates over Crio and returns an array of values where the keys map to a deeply-nested property on the collection item set {number} key, returns {CrioArray|CrioObject} Sets value at key setIn {Array&lt;number|string&gt;} keys, returns {CrioArray|CrioObject} Sets value in deeply nested object based on array of keys toArray, returns {CrioArray} Converts CrioObject to a CrioArray of the object's values toObject, returns {CrioObject} Converts CrioArray into a CrioObject of index: value pairs thaw, returns {Array&lt;any&gt;} Recursively thaws array deeply and returns standard object version of itself Arrays Default Methods concat copyWithin entries every fill Returns new crio with items from start to end filled with value filter find findIndex forEach includes Does a deep value equality comparison (rather than strict equality), so you can do things like crioArray.includes({foo: 'bar'}) indexOf join keys lastIndexOf map pop Returns new crio with first item removed push Returns new crio with new item added reduce reduceRight reverse shift Returns new crio with last item removed slice some sort Returns new crio sorted by either callback or default splice Returns new crio with items added/removed based on splicing parameters toLocaleString toString unshift Returns new crio with new items added to beginning values Added crio Methods difference {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that only exist in either the CrioArray or in one of the arrays passed findLastIndex {function} fn, returns {number} Same as findIndex but starting from end and working to start first {number} num, returns {CrioArray} Returns a new array of the first num number of items in the array intersection {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that exist in all of the arrays passed last {number} num, returns {CrioArray} Returns a new array of the last num number of items in the array unique, returns {CrioArray} Returns a new CrioArray of values filtered down to only existing in the array once xor {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that are the symmetric difference of the CrioArray and the arrays passed Objects Default Methods hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf Added crio Methods entries, returns {Array&lt;[string, any]&gt;} Gets an array of the [key, value] pairs in the CrioObject every {function(value, key, CrioObject): any} fn, {any} thisArg, returns {any} Performs same function as every in the Array prototype, but on the CrioObject forEach {function} fn, {any} thisArg, returns {CrioObject} Iterates over object executing fn Iteration order is not guaranteed filter {function} fn, {any} thisArg, returns {CrioObject} Iterates over object and filters out any returned values that are falsy Iteration order is not guaranteed findKey {function} fn, returns {number} Same as findIndex for CrioArray but finding the key instead of the index findLastKey {function} fn, returns {number} Same as findKey but starting from end and working to start includes {any} value, returns {boolean} Determine if the CrioObject has a value that deeply matches value in equality keys, returns {Array&lt;string&gt;} Returns an array of the keys in the CrioObject map {function} fn, {any} thisArg, returns {CrioObject} Iterates over object and maps returned value to the respective key Iteration order is not guaranteed reduce {function(accumulatedObject, value, key): any} fn, {any} thisArg, returns {any} Performs same function as reduce in the Array prototype, but on the CrioObject reduceRight {function(accumulatedObject, value, key): any} fn, {any} thisArg, returns {any} Performs same function as reduceRight in the Array prototype, but on the CrioObject some {function(value, key, CrioObject): any} fn, {any} thisArg, returns {any} Performs same function as some in the Array prototype, but on the CrioObject values, returns {Array&lt;any&gt;} Returns an array of the values in the CrioObject × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>

<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Source: index.js // external dependencies import isArray from 'lodash/isArray'; import isPlainObject from 'lodash/isPlainObject'; // Crio import {CrioArray, CrioObject} from './Crio'; // utils import {isCrio} from './utils'; /** * @module crio */ /** * @function crio * * @description * build a new crio object based on the object passed * * @param {*} [object={}] object to convert to crio * * @returns {CrioArray|CrioObject} object that has been crioed */ const crio = (object = {}) =&gt; { if (isArray(object)) { return new CrioArray(object); } if (isPlainObject(object)) { return new CrioObject(object); } if (isCrio(object)) { return object; } throw new TypeError( 'Object passed must be either an array or a plain object.' ); }; /** * @function crio.array * * @description * convenience method for making crio arrays * * @param {Array&lt;*&gt;} array array to crio * @returns {CrioArray} crio array */ crio.array = (array = []) =&gt; { if (!isArray(array)) { throw new TypeError('Object passed must be an array.'); } return crio(array); }; /** * @function crio.isArray * * @description * check if object is a crio array * * @param {*} object object to test * @returns {boolean} is the object a crio array */ crio.isArray = (object) =&gt; { return isCrio(object) &amp;&amp; object.isArray(); }; crio.isCrio = isCrio; /** * @function crio.isObject * * @description * check if object is a crio object * * @param {*} object object to test * @returns {boolean} is the object a crio object */ crio.isObject = (object) =&gt; { return isCrio(object) &amp;&amp; object.isObject(); }; /** * @function crio.object * * @description * convenience method for making crio objects * * @param {Object} object object to crio * @returns {CrioObject} crio object */ crio.object = (object = {}) =&gt; { if (!isPlainObject(object)) { throw new TypeError('Object passed must be a plain object.'); } return crio(object); }; export default crio; Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"Crio.js.html":{"id":"Crio.js.html","title":"Source: Crio.js","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Source: Crio.js // external dependencies import hashIt from 'hash-it'; import every from 'lodash/every'; import fill from 'lodash/fill'; import find from 'lodash/find'; import findKey from 'lodash/findKey'; import findLastKey from 'lodash/findLastKey'; import isArray from 'lodash/isArray'; import isUndefined from 'lodash/isUndefined'; import filter from 'lodash/filter'; import forEach from 'lodash/forEach'; import get from 'lodash/fp/get'; import map from 'lodash/map'; import merge from 'lodash/merge'; import reduce from 'lodash/reduce'; import reduceRight from 'lodash/reduceRight'; import set from 'lodash/fp/set'; import slice from 'lodash/slice'; import some from 'lodash/some'; import toPairs from 'lodash/toPairs'; import values from 'lodash/values'; // constants import { CRIO_ARRAY_TYPE, CRIO_OBJECT_TYPE, CRIO_SYMBOL, CRIO_TYPE, ITERATOR_PROPERTY_DESCRIPTOR, UNSCOPABLES_PROPERTY_DESCRIPTOR } from './constants'; // utils import { createAssignToObject, freeze, getCorrectConstructor, getCrioValue, getKeysMetadata, getRelativeValue, getStandardValue, hasOwnProperty, isCrio, isCrioArray, isEqual, keys, stringify } from './utils'; /** * @module Crio */ let assignToObject; /** * @class Crio * @classdesc base crio class * * @memberof module:Crio */ export class Crio { /** * @function constructor * * @description * add the items to the crio, and return a frozen version * * @param {Object} object object passed for crioing * @returns {Crio} crioed object */ constructor(object) { forEach(object, assignToObject(this, getCrioValue)); return freeze(this); } /** * @static */ static get ['@@species']() { return this; } get [CRIO_SYMBOL]() { return true; } get hashCode() { return hashIt(this); } /** * @function clear * @memberof! Crio# * * @description * get a new crio that is empty * * @returns {Crio} new empty crio instance */ clear() { return new this.constructor(this.isArray() ? [] : {}); } /** * @function compact * * @description * remove all falsy values from the crio * * @returns {Crio} new crio instance */ compact() { return this.filter((value) =&gt; { return !!value; }); } /** * @function delete * * @description * remove an item from the crio * * @param {number|string} key the key to remove from the crio * @returns {Crio} new crio instance with item removed */ delete(key) { const {[`${key}`]: deletedIgnored, ...updated} = this; return new this.constructor(this.isArray() ? values(updated) : updated); } /** * @function deleteIn * * @description * remove a nested item from the crio * * @param {Array&lt;number|string&gt;} keys the path of the item to remove * @returns {Crio} new crio instance with the item removed */ deleteIn(keys) { if (!keys || !keys.length) { return this; } if (keys.length === 1) { return this.delete(keys[0]); } const {currentValue, lastIndex, parentKeys} = getKeysMetadata(keys, this); if (!isCrio(currentValue)) { return this; } return this.setIn(parentKeys, currentValue.delete(keys[lastIndex])); } /** * @function entries * * @description * get the pairs of [key, value] in the crio * * @returns {Array&lt;Array&lt;string&gt;&gt;} [key, value] pairs */ entries() { return toPairs(this); } /** * @function equals * * @description * does the object passed equal the crio * * @param {*} object object to compare against the instance * @returns {boolean} is the object equal */ equals(object) { return isEqual(this, object); } /** * @function every * * @description * does every instance in the crio match * * @param {function} fn the function to test for matching * @param {*} [thisArg=this] argument for &quot;this&quot; to use in the iteration * @returns {boolean} does every instance match */ every(fn, thisArg = this) { return every(this, fn, thisArg); } /** * @function filter * * @description * get a reduced set from the crio * * @param {function} fn function to test for if it should be returned or not * @param {*} [thisArg=this] argument for &quot;this&quot; to use in the iteration * @returns {Crio} new crio instance */ filter(fn, thisArg = this) { const updated = this.isArray() ? filter(this, fn, thisArg) : reduce( this, (updatedValue, value, key) =&gt; { if (fn.call(thisArg, value, key, this)) { updatedValue[key] = value; } return updatedValue; }, {} ); return new this.constructor(updated); } /** * @function find * * @description * find an item in the crio if it exists * * @param {function} fn function to test for finding the item * @param {number} [fromKey] key to start from when performing the find * @returns {*} found item or undefined */ find(fn, fromKey) { return find(this, fn, fromKey); } /** * @function forEach * * @description * iterate over the crio calling fn * * @param {function} fn function to call in iteration * @param {*} [thisArg=this] argument to use as &quot;this&quot; in the iteration * @returns {Crio} new crio instance */ forEach(fn, thisArg = this) { forEach(this, fn, thisArg); return this; } /** * @function get * * @description * get the item at key passed * * @param {number|string} key key to retrieve * @returns {*} item found at key */ get(key) { return this[key]; } /** * @function getIn * * @description * get the nested item at the path passed * * @param {Array&lt;number|string&gt;} keys path to retrieve from * @returns {*} item found at nested path */ getIn(keys) { return keys &amp;&amp; keys.length ? get(keys, this) : this; } /** * @function has * * @description * does the crio have the key passed * * @param {number|string} key key to test * @returns {boolean} does the crio have the key */ has(key) { return hasOwnProperty.call(this, key); } /** * @function hasIn * * @description * does the crio have the nested key at the path passed * * @param {Array&lt;number|string&gt;} keys path to test * @returns {boolean} does the crio have the nested path */ hasIn(keys) { if (!keys || !keys.length) { return false; } if (keys.length === 1) { return this.has(keys[0]); } const {currentValue, lastIndex} = getKeysMetadata(keys, this); return isCrio(currentValue) &amp;&amp; currentValue.has(keys[lastIndex]); } /** * @function includes * * @description * does the crio have the value passed * * @param {*} value value to test for existence * @returns {boolean} does the value exist in the crio */ includes(value) { return this.some((currentValue) =&gt; { return currentValue === value; }); } /** * @function isArray * * @description * is the crio an array * * @returns {boolean} is the crio an array */ isArray() { return this[CRIO_TYPE] === CRIO_ARRAY_TYPE; } /** * @function isObject * * @description * is the crio an object * * @returns {boolean} is the crio an object */ isObject() { return this[CRIO_TYPE] === CRIO_OBJECT_TYPE; } /** * @function keys * * @description * get the keys of the crio * * @returns {Array&lt;string&gt;} keys in the crio */ keys() { return keys(this); } /** * @function map * * @description * iterate over the crio mapping the result of fn to the key * * @param {function} fn function to call on iteration * @param {*} [thisArg=this] argument to use as &quot;this&quot; in the iteration * @returns {Crio} new crio instance */ map(fn, thisArg = this) { const updated = this.isArray() ? map(this, fn, thisArg) : reduce( this, (updatedValue, value, key) =&gt; { updatedValue[key] = fn.call(thisArg, value, key, this); return updatedValue; }, {} ); return new this.constructor(updated); } /** * @function merge * * @description * merge objects with crio * * @param {...Array&lt;CrioArray|CrioObject|Object&gt;} objects objects to merge with the crio * @returns {Crio} new crio instance */ merge(...objects) { if (!objects.length) { return this; } return new this.constructor(merge({}, this.thaw(), ...objects)); } /** * @function mergeIn * * @description * merge the objects passed at the nested path in the crioArray * * @param {Array&lt;number|string&gt;} keys path to merge into * @param {...Array&lt;CrioArray|CrioObject|Object&gt;} objects objects to merge with the crio * @returns {Crio} new crio instance */ mergeIn(keys, ...objects) { if (!keys || !keys.length) { return this; } const valueToMerge = this.getIn(keys); if (!isCrio(valueToMerge)) { return this.setIn(keys, merge({}, ...objects)); } return new this.constructor( this.setIn(keys, valueToMerge.merge(...objects)) ); } /** * @function mutate * * @description * work with the object in a mutated way and return the crioed result of that call * * @param {function} fn function to apply to crio * @param {*} [thisArg=this] argument to use for &quot;this&quot; in the call * @returns {*} crioed value resulting from the call */ mutate(fn, thisArg = this) { const result = fn.call(thisArg, this.thaw(), this); return getCrioValue( result, getCorrectConstructor(result, CrioArray, CrioObject) ); } /** * @function pluck * * @description * get the values in each object in the collection at key * * @param {string} key key to find value of in collection object * @returns {Crio} new crio instance */ pluck(key) { return this.reduce((pluckedValues, value) =&gt; { pluckedValues.push( value &amp;&amp; hasOwnProperty.call(value, key) ? value[key] : undefined ); return pluckedValues; }, []); } /** * @function pluckIn * * @description * get the values in each object in the collection at the nested path * * @param {Array&lt;number|string&gt;} keys keys to find value of in collection object * @returns {Crio} new crio instance */ pluckIn(keys) { if (!keys || !keys.length) { return new CrioArray([]); } if (keys.length === 1) { return this.pluck(keys[0]); } const {currentValue, lastIndex} = getKeysMetadata(keys, this); return isCrio(currentValue) ? currentValue.pluck(keys[lastIndex]) : this; } /** * @function reduce * * @description * reduce the crio down to a single value, starting with initial value * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @param {*} [thisArg=this] argument to use for &quot;this&quot; in the call of fn * @returns {*} the reduced value */ reduce(fn, initialValue, thisArg = this) { const reducedValue = reduce.call(thisArg, this, fn, initialValue); return getCrioValue( reducedValue, getCorrectConstructor(reducedValue, CrioArray, CrioObject) ); } /** * @function reduceRight * * @description * reduce the crio down to a single value, starting with initial value, in reverse order * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @param {*} [thisArg=this] argument to use for &quot;this&quot; in the call of fn * @returns {*} the reduced value */ reduceRight(fn, initialValue, thisArg = this) { const reducedValue = reduceRight.call(thisArg, this, fn, initialValue); return getCrioValue( reducedValue, getCorrectConstructor(reducedValue, CrioArray, CrioObject) ); } /** * @function set * * @description * set the value at the key passed * * @param {number|string} key key to assign value to * @param {*} value value to assign * @returns {Crio} new crio instance */ set(key, value) { return new this.constructor({ ...this, [key]: value }); } /** * @function setIn * * @description * deeply set the value at the path passed * * @param {Array&lt;number|string&gt;} keys path to assign value to * @param {*} value value to assign * @returns {Crio} new crio instance */ setIn(keys, value) { return keys &amp;&amp; keys.length ? new this.constructor(set(keys, value, this)) : this; } /** * @function some * * @description * do any of the items in crio match per the fn passed * * @param {function} fn fn to iterate with * @param {*} [thisArg=this] argument to use as &quot;this&quot; in the iteration * @returns {boolean} are there any matches */ some(fn, thisArg = this) { return some(this, fn, thisArg); } /** * @function thaw * * @description * create a plain JS version of the crio * * @returns {Array&lt;*&gt;|Object} plain JS version of crio */ thaw() { const returnValue = this.isArray() ? [] : {}; forEach(this, assignToObject(returnValue, getStandardValue)); return returnValue; } /** * @function toArray * * @description * convert the crio to an array if it isnt already * * @returns {CrioArray} new crio array instance */ toArray() { return this.isArray() ? this : new CrioArray(values(this)); } /** * @function toLocaleString * * @description * convert the crio to stringified form * * @returns {string} stringified crio */ toLocaleString() { return this.toString(); } /** * @function toObject * * @description * convert the crio to an object if it isnt already * * @returns {CrioObject} new crio object instance */ toObject() { return this.isObject() ? this : new CrioObject( reduce( this, (object, value, key) =&gt; { object[key] = value; return object; }, {} ) ); } /** * @function toLocaleString * * @description * convert the crio to stringified form * * @returns {string} stringified crio */ toString() { return stringify(this); } /** * @function valueOf * * @description * noop for valueOf * * @returns {Crio} the same crio instance */ valueOf() { return this; } /** * @function values * * @description * get the values of the crio as an array * * @returns {Array&lt;*&gt;} values in the crio */ values() { return values(this); } } Object.defineProperties(Crio.prototype, { [Symbol.iterator]: ITERATOR_PROPERTY_DESCRIPTOR, [Symbol.unscopables]: UNSCOPABLES_PROPERTY_DESCRIPTOR }); /** * @class CrioArray * @classdesc extension of Crio class specific to arrays * * @memberof module:Crio */ export class CrioArray extends Crio { get length() { return keys(this).length; } /** * @function concat * * @description * append the items passed to the crio * * @param {...Array&lt;*&gt;} items items to append to the crio * @returns {CrioArray} new crio array instance */ concat(items) { const concatted = [...values(this), ...items]; return new CrioArray(concatted); } /** * @function copyWithin * * @description * move values around within the array * * @param {number} target target to copy * @param {number} [start=0] index to start copying to * @param {number} [end=this.length] index to stop copying to * @returns {CrioArray} new crio array instance */ copyWithin(target, start = 0, end = this.length) { const copiedArray = values(this); const length = this.length &gt;&gt;&gt; 0; let to = getRelativeValue(target &gt;&gt; 0, length), from = getRelativeValue(start &gt;&gt; 0, length); const final = getRelativeValue(end &gt;&gt; 0, length); let count = Math.min(final - from, length - to), direction = 1; if (from &lt; to &amp;&amp; to &lt; from + count) { direction = -1; from += count - 1; to += count - 1; } while (count &gt; 0) { if (from in copiedArray) { copiedArray[to] = copiedArray[from]; } else { delete copiedArray[to]; } from += direction; to += direction; count--; } return new CrioArray(copiedArray); } /** * @function difference * * @description * find the values in this that do not exist in any of the arrays passed * * @param {Array&lt;Array&gt;} arrays arrays to get the difference of * @returns {CrioArray} array of items matching diffference criteria */ difference(...arrays) { if (!arrays.length) { return this; } let indexOfValue; const difference = reduce( arrays, (differenceArray, array) =&gt; { if (isArray(array) || isCrioArray(array)) { forEach(array, (value) =&gt; { indexOfValue = differenceArray.indexOf(value); if (!!~indexOfValue) { differenceArray.splice(indexOfValue, 1); } }); } return differenceArray; }, this.isArray ? values(this) : {...this} ); return new CrioArray(difference); } /** * @function fill * * @description * fill the array at certain indices with the value passed * * @param {*} value the value to fill the indices with * @param {number} [start=0] the starting index to fill * @param {number} [end=this.length] the ending index to fill * @returns {CrioArray} new crio array instance */ fill(value, start = 0, end = this.length) { const filled = fill(values(this), value, start, end); return new CrioArray(filled, this); } /** * @function findIndex * * @description * find the matching index based on truthy return from fn * * @param {function} fn function to use for test in iteration * @param {*} [thisArg=this] argument to use as &quot;this&quot; in fn call * @returns {number} index of match, or -1 */ findIndex(fn, thisArg = this) { const index = findKey(this, (value, key) =&gt; { return fn.call(thisArg, value, +key, this); }); return isUndefined(index) ? -1 : +index; } /** * @function findLastIndex * * @description * find the matching index based on truthy return from fn starting from end * * @param {function} fn function to use for test in iteration * @param {*} [thisArg=this] argument to use as &quot;this&quot; in fn call * @returns {number} index of match, or -1 */ findLastIndex(fn, thisArg = this) { const index = findLastKey(this, (value, key) =&gt; { return fn.call(thisArg, value, +key, this); }); return isUndefined(index) ? -1 : +index; } /** * @function first * * @description * take the first n number of items in the array * * @param {number} [size=1] size of elements to take from beginning of array * @returns {CrioArray} */ first(size = 1) { return this.slice(0, size); } /** * @function indexOf * * @description * get the index of the value passed * * @param {*} value value to find in crio * @returns {number} index of match, or -1 */ indexOf(value) { return this.findIndex((thisValue) =&gt; { return thisValue === value; }); } /** * @function intersection * * @description * find the values in that exist in this and each of the arrays passed * * @param {Array&lt;Array&gt;} arrays * @returns {CrioArray} */ intersection(...arrays) { if (!arrays.length) { return this; } const allArrays = [this, ...arrays]; const allArraysLength = allArrays.length; let indices = [], indexOfValue; const reducedArrays = reduce( allArrays, (values, array) =&gt; { if (isArray(array) || isCrioArray(array)) { forEach(array, (value) =&gt; { indexOfValue = values.indexOf(value); if (!!~indexOfValue) { indices[indexOfValue]++; } else { indices[values.length] = 1; values.push(value); } }); } return values; }, [] ); const filteredArrays = filter(reducedArrays, (value, index) =&gt; { return indices[index] === allArraysLength; }); return new CrioArray(filteredArrays); } /** * @function join * * @description * join the values in the crio as a string, combined with separator * * @param {string} [separator=','] character(s) to place between strings in combination * @returns {string} parameters joined by separator in string */ join(separator = ',') { return this.thaw().join(separator); } /** * @function last * * @description * take the last n number of items in the array * * @param {number} [size=1] size of elements to take from end of array * @returns {CrioArray} */ last(size = 1) { return this.slice(this.length - size); } /** * @function lastIndexOf * * @description * get the last index of the value passed * * @param {*} value value to find in crio * @returns {number} index of match, or -1 */ lastIndexOf(value) { return this.findLastIndex((thisValue) =&gt; { return thisValue === value; }); } /** * @function pop * * @description * get crio based on current crio with last item removed * * @returns {CrioArray} new crio array instance */ pop() { return this.slice(0, this.length - 1); } /** * @function push * * @description * push one to many items to the current crio * * @param {...Array&lt;*&gt;} items the items to add to the array * @returns {CrioArray} the new crio array instance */ push(...items) { return this.concat(items); } /** * @function reverse * * @description * get the same values, but in reverse order * * @returns {CrioArray} new crio array instance */ reverse() { let reversed = values(this); reversed.reverse(); return new CrioArray(reversed); } /** * @function shift * * @description * get crio based on current crio with first item removed * * @returns {CrioArray} new crio array instance */ shift() { return this.slice(1); } /** * @function slice * * @description * get a new crio array based on a subset of the current crio * * @param {number} [start=0] first index to include * @param {number} [end=this.length] size of array from first index * @returns {CrioArray} new crio array instance */ slice(start = 0, end = this.length) { const sliced = slice(this, start, end); return new CrioArray(sliced); } /** * @function sort * * @description * sort the collection by the fn passed * * @param {function} fn the function to sort based on * @returns {CrioArray} new crio array instance */ sort(fn) { let sorted = values(this); sorted.sort(fn); return new CrioArray(sorted); } /** * @function splice * * @description * splice the values into or out of the array * * @param {number} [start=0] starting index to splice * @param {number} [deleteCount=1] length from starting index to removes * @param {...Array&lt;*&gt;} items items to insert after delete is complete * @returns {CrioArray} new crio array instance */ splice(start = 0, deleteCount = 1, ...items) { let spliced = values(this); spliced.splice(start, deleteCount, ...items); return new CrioArray(spliced); } /** * @function unique * * @description * return the current CrioArray with the duplicate values removed * * @returns {CrioArray} new crio instance */ unique() { let hashArray = [], newArray = [], hasHashCode = false, hashCode, storeValue; return this.filter((value) =&gt; { hashCode = !!value ? value.hashCode : undefined; hasHashCode = !isUndefined(hashCode); storeValue = !~newArray.indexOf(value) &amp;&amp; (!hasHashCode || !~hashArray.indexOf(hashCode)); if (storeValue) { newArray.push(value); if (hasHashCode) { hashArray.push(hashCode); } } return storeValue; }); } /** * @function unshift * * @description * add items passed to the beginning of the crio array * * @param {...Array&lt;*&gt;} items items to prepend to the array * @returns {CrioArray} new crio array instance */ unshift(...items) { return items.length ? new CrioArray([...items, ...values(this)]) : this; } /** * @function xor * * @description * find the values that are the symmetric difference of this and the arrays passed * * @param {Array&lt;Array&gt;} arrays arrays to find symmetric values in * @returns {CrioArray} new crio array instance */ xor(...arrays) { if (!arrays.length) { return this; } const allArrays = [this, ...arrays]; let indicesToRemove = [], indexOfValue; const reducedValues = reduce( allArrays, (values, array) =&gt; { if (isArray(array) || isCrioArray(array)) { forEach(array, (value) =&gt; { indexOfValue = values.indexOf(value); if (!!~indexOfValue) { indicesToRemove.push(indexOfValue); } else { values.push(value); } }); } return values; }, [] ); const xorValues = filter(reducedValues, (value, index) =&gt; { return !~indicesToRemove.indexOf(index); }); return new CrioArray(xorValues); } } Object.defineProperties(CrioArray.prototype, { [CRIO_TYPE]: { configurable: false, enumerable: false, value: CRIO_ARRAY_TYPE, writable: false } }); /** * @class CrioObject * @classdesc extension of Crio class specific to objects * * @memberof module:Crio */ export class CrioObject extends Crio { get size() { return keys(this).length; } /** * @function findKey * * @description * find a specific key based on a matching function * * @param {function} fn function to match * @returns {string|undefined} key matching fn */ findKey(fn) { return findKey(this, fn); } /** * @function findLastKey * * @description * find a specific key based on a matching function, starting from the end * * @param {function} fn function to match * @returns {string|undefined} key matching fn */ findLastKey(fn) { return findLastKey(this, fn); } } Object.defineProperties(CrioObject.prototype, { [CRIO_TYPE]: { configurable: false, enumerable: false, value: CRIO_OBJECT_TYPE, writable: false } }); assignToObject = createAssignToObject(CrioArray, CrioObject); Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Source: utils.js // external dependencies import deepFreeze from 'deep-freeze-strict'; import identity from 'lodash/identity'; import isArray from 'lodash/isArray'; import isPlainObject from 'lodash/isPlainObject'; import stringifier from 'stringifier'; // constants import { CRIO_SYMBOL, IS_PRODUCTION, REACT_ELEMENT_TYPE, STRINGIFIER_OPTIONS } from './constants'; /** * @private * * @function freeze * * @description * freeze the object if it is production * * @param {CrioArray|CrioObject} crio object to freeze * * @returns {T} frozen object */ export const freeze = ((isProduction) =&gt; { return isProduction ? identity : deepFreeze; })(IS_PRODUCTION); export const hasOwnProperty = Object.prototype.hasOwnProperty; /** * @private * * @function isComplexObject * * @description * is the object an array or plain object * * @param {*} object object to test * * @returns {boolean} is the object a complex object */ export const isComplexObject = (object) =&gt; { return isArray(object) || isPlainObject(object); }; /** * @private * * @function isCrio * * @description * is the object a crio object or not * * @param {*} object object to test * * @returns {boolean} is the object a crio */ export const isCrio = (object) =&gt; { return !!(object &amp;&amp; object[CRIO_SYMBOL]); }; /** * @private * * @function isCrioArray * * @description * is the object a crio array * * @param {*} object object to test * @returns {boolean} is the object a crio array */ export const isCrioArray = (object) =&gt; { return isCrio &amp;&amp; object.isArray(); }; /** * @private * * @function isEqual * * @description * are the crio objects equal * * @param {CrioArray|CrioObject} crio crio object to test against * @param {*} object object to test equality with crio object for * * @returns {boolean} are the objects equal */ export const isEqual = (crio, object) =&gt; { return isCrio(object) &amp;&amp; crio.hashCode === object.hashCode; }; /** * @private * * @function isReactElement * * @description * is the object passed a react element * * @param {*} object object to test * @returns {boolean} is object a react element */ export const isReactElement = (object) =&gt; { return !!object &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE; }; /** * @private * * @function getCorrectConstructor * * @description * get the constructor that is valid for the object type passed * * @param {*} object object to test * @param {CrioArray} CrioArray constructor for CrioArray class * @param {CrioObject} CrioObject constructor for CrioObject class * @returns {CrioArray|CrioObject} constructor correct for object */ export const getCorrectConstructor = (object, CrioArray, CrioObject) =&gt; { return isArray(object) ? CrioArray : CrioObject; }; /** * @private * * @function getCrioValue * * @description * get the value based on its type * * @param {*} object object to get value of * @param {Function} Constructor function to call new of if object is complex * * @returns {*} object with clean value */ export const getCrioValue = (object, Constructor) =&gt; { if (isCrio(object) || isReactElement(object)) { return object; } if (isComplexObject(object)) { return new Constructor(object); } return object; }; /** * @private * * @function getKeysMetadata * * @description * get the value at the parent key location * * @param {Array&lt;number|string&gt;} keys keys to get value of * @param {CrioArray|CrioObject} instance crio instance * * @returns {{currentValue: *, lastIndex: number}} parent key metadata */ export const getKeysMetadata = (keys, instance) =&gt; { const lastIndex = keys.length - 1; const parentKeys = keys.slice(0, lastIndex); const currentValue = instance.getIn(parentKeys); return { currentValue, lastIndex, parentKeys }; }; /** * @private * * @function getRelativeValue * * @description * get the relative value used in copyWithin * * @param {number} value value used as baseline * @param {number} length the length of the crio * @returns {number} the relative number value */ export const getRelativeValue = (value, length) =&gt; { return value &lt; 0 ? Math.max(length + value, 0) : Math.min(value, length); }; /** * @private * * @function getStandardValue * * @description * get the standard value (thawed if crio) * * @param {*} object object to get standard version of * * @returns {*} standard version of object */ export const getStandardValue = (object) =&gt; { return isCrio(object) ? object.thaw() : object; }; /** * @private * * @function createAssignToObject * * @description * create a function that will assign a value to an object * * @param {Function} CrioArray constructor for crio arrays * @param {Function} CrioObject constructor for crio objects * * @returns {function((Array&lt;*&gt;|Object), function): function(*, string): void} assignment function */ export const createAssignToObject = (CrioArray, CrioObject) =&gt; { return (object, getValue) =&gt; { return (value, key) =&gt; { object[key] = getValue( value, getCorrectConstructor(value, CrioArray, CrioObject) ); }; }; }; /** * @function keys * * @description * get the keys for the given object * * @param {Object} object the object to get the keys for * @returns {Array&lt;string&gt;} the array of keys */ export const keys = (object) =&gt; { let ownKeys = []; for (let key in object) { if (hasOwnProperty.call(object, key)) { ownKeys.push(key); } } return ownKeys; }; /** * @private * * @function stringify * * @description * convert object to string * * @param {*} object object to stringify * * @returns {string} stringified version of object */ export const stringify = stringifier(STRINGIFIER_OPTIONS); Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Global Methods keys(object) get the keys for the given object Parameters: Name Type Description object Object the object to get the keys for Source: utils.js, line 251 Returns: the array of keys Type Array.&lt;string&gt; Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Modules Classes Crio CrioArray CrioObject Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Classes Classes Crio CrioArray CrioObject Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Tutorials Classes Crio CrioArray CrioObject Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys crio 4.1.1 crio Immutable JS objects with a natural API Jump to the API API Documentation Upgrade notice If upgrading from 3.x.x versions, please check the changelog for breaking changes. Import into your project // ES2015 import crio from 'crio'; // CommonJS const crio = require('crio'); // UMD const crio = window.crio;Usage // you can assign with crio() directly const crioArray = crio(['foo']); const crioObject = crio({foo: 'bar'}); // or use the convenience methods const otherCrioArray = crio.array(['bar']); const otherCrioObject = crio.object({bar: 'baz'});What is immutable? When something is described as immutable, it means that it cannot change after it has been created. In JavaScript terms, this means that any attempted change to an object results in a brand new object being created, without changing the original object. Why do we need this in JavaScript? The concept of immutability already exists in a lot of places in JavaScript, for example: const two = 2; const three = 3; const five = two + three;By adding together two and three you expect to get five, however you don't expect the value of two to change. You can continue working with it even after using it in an expression: const two = 2; const three = 3; const five = two + three; const four = two * two;This is true of strings, numbers, undefined, and null, and is an expected behavior. The same idea, however, is not true for complex objects in JavaScript. For example: const foo = ['foo']; const fooBar = foo.push('bar');The expectation is that you have pushed the value of &quot;bar&quot; into foo and created a new array bar that contains &quot;foo, bar&quot;, however in reality this is what happens: const foo = ['foo']; const fooBar = foo.push('bar'); console.log(foo); // ['foo', 'bar'] console.log(fooBar); // 1Basically, you have mutated foo so that it is no longer empty, and what the .push() method returns is actually the index of the item you just added. This double-standard of expectations creates a lot confusion from a development perspective, but also makes keeping track of the state of your application very difficult because there is no traceability of what transactions have occurred to create that state at any given point. Enter crio crio attempts to solve the problem by closing the &quot;immutable loop&quot; on collection items, meaning it applies immutability to objects that are normally mutable by nature by replacing mutating methods with immutable counterparts. As a point of reference: Naturally immutable objects Numbers Strings undefined null Naturally mutable objects Arrays Dates (not covered by crio) Objects To create a new crio object, its pretty straightforward: const crioArray = crio([]); const crioObject = crio({}); // or just crio()These are examples with empty objects, but you can pass in populated objects as well, or if you pass in nothing it will default to an object. What crio does is clone and freeze the object via Object.freeze, and stores as a custom CrioArray or CrioObject with a prototypical methods that will return a new immutable version of the object with each update. Example: const foo = crio(['foo']); const fooBar = foo.push('bar'); console.log(foo); // ['foo'] console.log(fooBar); // ['foo', 'bar']The API is the same as you already know working with those objects, and includes polyfills for all ES6 and some ES7 functions, as well as a few helpful crio-specific functions. The only difference is that any setting happens via .set() rather than direct index / property setting. You can work with the objects as you normally would with other libraries (lodash, for example). There is also no change to the protoypes of native objects, so you can apply this on your existing code go-forward. Basically, you shouldn't even notice you aren't working with the native objects, save for the fact everything is immutable. Why not just use X immutable library? There are a bunch of ones out there, but the two that people usually gravitate towards: Immutable.js seamless-immutable immutable is quite nice, and very highly regarded by the community, however it creates an opaque object that cannot be used with other external libraries (namely lodash) without converting back to vanilla JS. Additionally, the object itself is not truly immutable, just constructed in a way that makes it incredibly difficult to alter outside of the API. This decision was likely made for performance reasons, but can cause unintended consequences (you can totally assign foo.bar = 'baz' and no error is thrown). seamless-immutable has some great ideas, and I thought that could be the best option because they try to retain the native operations while leveraging Object.freeze, much like crio does. That said, they do not try to replace mutable methods with immutable ones, they just throw errors when you attempt them and its up to you to figure out the &quot;right way&quot;. As such, it fell short of my expectations. Bottom line, I support each of these projects to the fullest because they are trying to instill immutability in JavaScript practices; I just took a different approach that I consider the best of both worlds. :) Browser support The only requirement is that your browser has a proper ES5 environment, which you can mostly shim with something like es5-shim, however certain things like Object.defineProperty cannot be shimmed, so IE8 and below cannot be supported. crio has been tested on the following browsers: Chrome Firefox Edge IE9 Performance As of 4.0.0, performance has substantially improved, and in many scenarios crio is more performant than seamless-immutable (in the case of setIn, by over 5x). When it comes to get operations (either directly or nested), crio is identical to native in performance. See the benchmark results if you want to see performance in node, or spin up the app locally if you want to see the performance in the browser. Gotchas Recursive objects are not allowed Immutable objects with recursive values are basically impossible, and trying them will cause a stack overflow, so be mindful of that! Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: benchmark =&gt; run benchmarks in node benchmark:watch =&gt; run benchmark with persistent watcher for changes build =&gt; run webpack to build crio.js with NODE_ENV=development build:minifed =&gt; run webpack to build crio.min.js with NODE_ENV=production compile-for-publish =&gt; run lint, test, transpile, dist dev =&gt; run webpack dev server to run example app (playground!) dev:production =&gt; runs dev but with NODE_ENV=production dist =&gt; runs build and build-minified lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish test =&gt; run AVA test functions with NODE_ENV=test test:watch =&gt; same as test, but runs persistent watcher transpile =&gt; run babel against all files in src to create files in lib Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-crio.html":{"id":"module-crio.html","title":"Module: crio","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Module: crio Source: index.js, line 21 Methods &lt;inner&gt; crio( [object]) build a new crio object based on the object passed Parameters: Name Type Argument Default Description object * &lt;optional&gt; {} object to convert to crio Source: index.js, line 25 Returns: object that has been crioed Type CrioArray | CrioObject Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-Crio_.html":{"id":"module-Crio_.html","title":"Module: Crio","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Module: Crio Source: Crio.js, line 119 Classes Crio CrioArray CrioObject Methods &lt;inner&gt; concat(items) append the items passed to the crio Parameters: Name Type Argument Description items Array.&lt;*&gt; &lt;repeatable&gt; items to append to the crio Source: Crio.js, line 899 Returns: new crio array instance Type CrioArray &lt;inner&gt; constructor(object) add the items to the crio, and return a frozen version Parameters: Name Type Description object Object object passed for crioing Source: Crio.js, line 133 Returns: crioed object Type Crio &lt;inner&gt; findKey(fn) find a specific key based on a matching function Parameters: Name Type Description fn function function to match Source: Crio.js, line 1496 Returns: key matching fn Type string | undefined Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-Crio.Crio.html":{"id":"module-Crio.Crio.html","title":"Class: Crio","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Class: Crio Crio. Crio base crio class new Crio() Source: Crio.js, line 125 Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-Crio.CrioArray.html":{"id":"module-Crio.CrioArray.html","title":"Class: CrioArray","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Class: CrioArray Crio. CrioArray extension of Crio class specific to arrays new CrioArray() Source: Crio.js, line 879 Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-Crio.CrioObject.html":{"id":"module-Crio.CrioObject.html","title":"Class: CrioObject","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys Class: CrioObject Crio. CrioObject extension of Crio class specific to objects new CrioObject() Source: Crio.js, line 1476 Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"tutorial-API.html":{"id":"tutorial-API.html","title":"Tutorial: API","body":" crio Modules crioCrio Classes Crio.CrioCrio.CrioArrayCrio.CrioObject Tutorials API Global keys API crio API Instantiation crio {any}, returns CrioArray|CrioObject Standard method, will crio the object passed if an array or object, else it will return the object itself crio.array {Array&lt;any&gt;}, returns CrioArray Shortcut method for crioing array-specific values crio.object {Object}, returns CrioObject Shortcut method for crioing object-specific values crio.isCrio {any}, returns boolean Determine if the object passed is a Crio crio.isArray {any}, returns boolean Determine if the object passed is a CrioArray crio.isObject {any}, returns boolean Determine if the object passed is a CrioObject Methods with the same name as the native method will be a link to MDN, as they are meant to be as similar to the native method as possible. Where any specific differences from the default behavior exist, they will be called out, however one broad difference is that all methods that are not getters which return primitive values are chainable. Shared Methods The following methods are specific to Crio types, and are available on either CrioArray or CrioObject clear, returns {CrioArray|CrioObject} returns an empty Crio compact, returns {CrioArray|CrioObject} returns a new Crio with all falsy values filtered out delete {number} key, returns {CrioArray|CrioObject} Deletes the key provided from the crio object deleteIn {Array&lt;number|string&gt;} keys, returns {CrioArray|CrioObject} Deletes the final key based on the array of keys nested inside of the crio object equals {CrioArray|CrioObject} crioArrayToCompare, returns {boolean} Determines whether array is deeply equal in value to another by comparing hashCodes get {number} key, returns {any} Retrieve value at key getIn {Array&lt;number|string&gt;} keys, returns {any} Retrieve value in deeply nested object based on array of keys has {string} key, returns {boolean} Alias for hasOwnProperty hasIn {Array&lt;number|string&gt;} keys, returns {boolean} Does the Crio have the combination of keys assigned deeply merge {Object[, Object2, ..., ObjectN]} objects, returns {CrioArray|CrioObject} Shallow merge any number of items into existing crio mergeIn {Array&lt;number|string&gt;} keys, {Object[, Object2, ..., ObjectN]} objects, returns {CrioArray|CrioObject} Shallow merge any number of items into value existing in deeply nested object based on array of keys mutate {function(mutableCrio, originalCrio): any} callback, returns {CrioArray|CrioObject} Whatever you return in the callback is what is returned, or if you return nothing it returns the original Crio pluck {number|string} key, returns {CrioArray|CrioObject} Iterates over Crio and returns an array of values where the key exists as a property on the collection item pluckIn {Array&lt;number|string} keys, returns {CrioArray|CrioObject} Iterates over Crio and returns an array of values where the keys map to a deeply-nested property on the collection item set {number} key, returns {CrioArray|CrioObject} Sets value at key setIn {Array&lt;number|string&gt;} keys, returns {CrioArray|CrioObject} Sets value in deeply nested object based on array of keys toArray, returns {CrioArray} Converts CrioObject to a CrioArray of the object's values toObject, returns {CrioObject} Converts CrioArray into a CrioObject of index: value pairs thaw, returns {Array&lt;any&gt;} Recursively thaws array deeply and returns standard object version of itself Arrays Default Methods concat copyWithin entries every fill Returns new crio with items from start to end filled with value filter find findIndex forEach includes Does a deep value equality comparison (rather than strict equality), so you can do things like crioArray.includes({foo: 'bar'}) indexOf join keys lastIndexOf map pop Returns new crio with first item removed push Returns new crio with new item added reduce reduceRight reverse shift Returns new crio with last item removed slice some sort Returns new crio sorted by either callback or default splice Returns new crio with items added/removed based on splicing parameters toLocaleString toString unshift Returns new crio with new items added to beginning values Added crio Methods difference {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that only exist in either the CrioArray or in one of the arrays passed findLastIndex {function} fn, returns {number} Same as findIndex but starting from end and working to start first {number} num, returns {CrioArray} Returns a new array of the first num number of items in the array intersection {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that exist in all of the arrays passed last {number} num, returns {CrioArray} Returns a new array of the last num number of items in the array unique, returns {CrioArray} Returns a new CrioArray of values filtered down to only existing in the array once xor {Array&lt;*&gt;} array[, array2, ..., arrayN], returns {CrioArray} Returns a new array of the values that are the symmetric difference of the CrioArray and the arrays passed Objects Default Methods hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf Added crio Methods entries, returns {Array&lt;[string, any]&gt;} Gets an array of the [key, value] pairs in the CrioObject every {function(value, key, CrioObject): any} fn, {any} thisArg, returns {any} Performs same function as every in the Array prototype, but on the CrioObject forEach {function} fn, {any} thisArg, returns {CrioObject} Iterates over object executing fn Iteration order is not guaranteed filter {function} fn, {any} thisArg, returns {CrioObject} Iterates over object and filters out any returned values that are falsy Iteration order is not guaranteed findKey {function} fn, returns {number} Same as findIndex for CrioArray but finding the key instead of the index findLastKey {function} fn, returns {number} Same as findKey but starting from end and working to start includes {any} value, returns {boolean} Determine if the CrioObject has a value that deeply matches value in equality keys, returns {Array&lt;string&gt;} Returns an array of the keys in the CrioObject map {function} fn, {any} thisArg, returns {CrioObject} Iterates over object and maps returned value to the respective key Iteration order is not guaranteed reduce {function(accumulatedObject, value, key): any} fn, {any} thisArg, returns {any} Performs same function as reduce in the Array prototype, but on the CrioObject reduceRight {function(accumulatedObject, value, key): any} fn, {any} thisArg, returns {any} Performs same function as reduceRight in the Array prototype, but on the CrioObject some {function(value, key, CrioObject): any} fn, {any} thisArg, returns {any} Performs same function as some in the Array prototype, but on the CrioObject values, returns {Array&lt;any&gt;} Returns an array of the values in the CrioObject Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>

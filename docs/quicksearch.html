<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"constants.js.html":{"id":"constants.js.html","title":"Source: constants.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: constants.js // utils import {every, find, some} from './utils'; /** * @constant {Object} ARRAY_UNSCOPABLES */ export const ARRAY_UNSCOPABLES = { copyWithin: true, entries: true, fill: true, find: true, findIndex: true, findLastIndex: true, includes: true, keys: true, values: true }; /** * @constant {Object} ARRAY_FALLBACK_PROTOTYPE_METHODS */ export const ARRAY_FALLBACK_PROTOTYPE_METHODS = { /** * @function every * * @description * does every instance in the array match * * @param {function} fn the function to test for matching * @returns {boolean} does every instance match */ every(fn) { return every(this, fn); }, /** * @function find * * @description * find an item in the array if it exists * * @param {function} fn function to test for finding the item * @returns {*} found item or undefined */ find(fn) { return find(this, fn); }, /** * @function findIndex * * @description * find the index of an item in the array if it exists * * @param {function} fn function to test for finding the item * @returns {number} index of match, or -1 */ findIndex(fn) { return find(this, fn, true); }, /** * @function includes * * @description * does the array have the item passed * * @param {*} item item to test for existence * @returns {boolean} does the item exist in the array */ includes(item) { return !!~this.indexOf(item); }, /** * @function some * * @description * does any item in the array match the result from fn * * @param {function} fn the function to test for matching * @returns {boolean} does any item match */ some(fn) { return some(this, fn); } }; /** * @constant {Object} ARRAY_UNSCOPABLES */ export const OBJECT_UNSCOPABLES = { entries: true, fill: true, find: true, findKey: true, findLastKey: true, includes: true, keys: true, values: true }; /** * @constant {Symbol|number} */ export const REACT_ELEMENT_TYPE = typeof Symbol === 'function' &amp;&amp; Symbol.for ? Symbol.for('react.element') : 0xeac7; Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"CrioArray.js.html":{"id":"CrioArray.js.html","title":"Source: CrioArray.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: CrioArray.js // external dependencies import stringify from 'json-stringify-safe'; import hashIt from 'hash-it'; import {parse} from 'pathington'; import {get, has, merge, remove, set} from 'unchanged'; // classes import CrioObject from './CrioObject'; // constants import {ARRAY_FALLBACK_PROTOTYPE_METHODS, ARRAY_UNSCOPABLES} from './constants'; // is import {isArray, isCrio, isEqual, isUndefined} from './is'; // utils import { createIterator, find, getCrioedObject, getEntries, getRelativeValue, getValues, thaw } from './utils'; let hasAppliedPrototype = false; class CrioArray extends Array { constructor(array) { super(isArray(array) ? array.length : array || 0); if (!hasAppliedPrototype) { applyPrototype(); hasAppliedPrototype = true; } if (isCrio(array)) { return array.toArray(); } return isArray(array) ? array.reduce((crioArray, item, index) =&gt; { crioArray[index] = getCrioedObject(item); return crioArray; }, this) : this; } get hashCode() { return hashIt(this, true); } /** * @function clear * @memberof CrioArray *folder * @description * get a new empty array * * @returns {CrioArray} the empty array */ clear() { return new CrioArray(); } /** * @function compact * @memberof CrioArray * * @description * get a new array with values from the original array that are truthy * * @returns {CrioArray} the array with only truthy values */ compact() { return this.filter((item) =&gt; { return !!item; }); } /** * @function copyWithin * * @description * move values around within the array * * @param {number} targetIndex target to copy * @param {number} [startIndex=0] index to start copying to * @param {number} [endIndex=this.length] index to stop copying to * @returns {CrioArray} array with target copied in appropriate spots */ copyWithin(targetIndex, startIndex = 0, endIndex = this.length) { const clone = [...this]; const length = this.length &gt;&gt;&gt; 0; let to = getRelativeValue(targetIndex &gt;&gt; 0, length), from = getRelativeValue(startIndex &gt;&gt; 0, length); const final = getRelativeValue(endIndex &gt;&gt; 0, length); let count = Math.min(final - from, length - to), direction = 1; if (from &lt; to &amp;&amp; to &lt; from + count) { direction = -1; from += count - 1; to += count - 1; } while (count &gt; 0) { if (from in clone) { clone[to] = clone[from]; } else { delete clone[to]; } from += direction; to += direction; count--; } return new this.constructor(clone); } /** * @function delete * @memberof CrioArray * * @description * delete the value in the array at key, either shallow or deep * * @param {Array&lt;number|string&gt;|number} key the key to delete * @returns {CrioArray} the array with the key deleted */ delete(key) { return remove(key, this); } /** * @function difference * @memberof CrioArray * * @description * find the values in this that do not exist in any of the arrays passed * * @param {...Array&lt;Array&lt;*&gt;&gt;} arrays arrays to get the difference of * @returns {CrioArray} array of items matching diffference criteria */ difference(...arrays) { if (!arrays.length) { return this; } let indexOfItem; return arrays.reduce((differenceArray, array) =&gt; { if (isArray(array)) { array.forEach((item) =&gt; { indexOfItem = differenceArray.indexOf(item); if (~indexOfItem) { differenceArray = differenceArray.splice(indexOfItem, 1); } }); } return differenceArray; }, this); } /** * @function entries * @memberof CrioArray * * @description * get the pairs of [key, value] in the crio * * @returns {CrioArray} [key, value] pairs */ entries() { return getEntries(this); } /** * @function equals * @memberof CrioArray * * @description * does the object passed equal the crio * * @param {*} object object to compare against the instance * @returns {boolean} is the object equivalent in value */ equals(object) { return isEqual(this, object); } /** * @function fill * * @description * fill the array at certain indices with the value passed * * @param {*} value the value to fill the indices with * @param {number} [startIndex=0] the starting index to fill * @param {number} [endIndex=this.length] the ending index to fill * @returns {CrioArray} array with values filled appropriately */ fill(value, startIndex = 0, endIndex = this.length) { const from = startIndex &lt; 0 ? this.length + startIndex : startIndex; const to = endIndex &lt; 0 ? this.length + endIndex : endIndex; const crioedValue = getCrioedObject(value); return this.map((item, index) =&gt; { return index &gt;= from &amp;&amp; index &lt; to ? crioedValue : item; }); } /** * @function findLast * @memberof CrioArray * * @description * find an item in the crio if it exists, starting from the end and iteratng to the start * * @param {function} fn function to test for finding the item * @returns {*} found item or undefined */ findLast(fn) { return find(this, fn, false, true); } /** * @function findLastIndex * @memberof CrioArray * * @description * find the matching index based on truthy return from fn starting from end * * @param {function} fn function to use for test in iteration * @returns {number} index of match, or -1 */ findLastIndex(fn) { return find(this, fn, true, true); } /** * @function first * @memberof CrioArray * * @description * take the first n number of items in the array * * @param {number} [size=1] size of elements to take from beginning of array * @returns {CrioArray} */ first(size = 1) { return this.slice(0, size); } /** * @function forEach * @memberof CrioArray * * @description * iterate over the array executing fn * * @param {function} fn the function to execute * @returns {CrioArray} the original array */ forEach(fn) { Array.prototype.forEach.call(this, fn); return this; } /** * @function get * @memberof CrioArray * * @description * get the item at key passed, either shallow or deeply nested * * @param {Array&lt;number|string&gt;|number} key key to retrieve * @returns {*} item found at key */ get(key) { return get(key, this); } /** * @function has * @memberof CrioArray * * @description * does the crio have the key passed, either shallow or deeply nested * * @param {Array&lt;number|string&gt;|number} key key to test * @returns {boolean} does the crio have the key */ has(key) { return has(key, this); } /** * @function intersection * @memberof CrioArray * * @description * find the values in that exist in this and each of the arrays passed * * @param {...Array&lt;Array&gt;} arrays to find the intersecting values of * @returns {CrioArray} array of values that exist in all arrays */ intersection(...arrays) { if (!arrays.length) { return this; } let indices = [], indexOfItem; const reducedArrays = [this, ...arrays].reduce((items, array) =&gt; { if (isArray(array)) { array.forEach((item) =&gt; { indexOfItem = items.indexOf(item); if (~indexOfItem) { return indices[indexOfItem]++; } indices[items.length] = 1; items.push(item); }); } return items; }, []); const newLength = arrays.length + 1; return new CrioArray( reducedArrays.filter((itemIgnored, index) =&gt; { return indices[index] === newLength; }) ); } /** * @function isArray * @memberof CrioArray * * @description * is the crio an array * * @returns {boolean} is the crio an array */ isArray() { return true; } /** * @function isObject * @memberof CrioArray * * @description * is the crio an object * * @returns {boolean} is the crio an object */ isObject() { return false; } /** * @function join * @memberof CrioArray * * @description * join the values in the crio as a string, combined with separator * * @param {string} [separator] character(s) to place between strings in combination * @returns {string} parameters joined by separator in string */ join(separator) { return this.thaw().join(separator); } /** * @function keys * @memberof CrioArray * * @description * get the keys of the crio * * @returns {CrioArray&lt;number&gt;} keys in the crio */ keys() { return new CrioArray(Object.keys(this).map(Number)); } /** * @function last * @memberof CrioArray * * @description * take the last n number of items in the array * * @param {number} [size=1] size of elements to take from end of array * @returns {CrioArray} */ last(size = 1) { return this.slice(this.length - size); } /** * @function map * @memberof CrioArray * * @description * map over the array returning the mapped items * * @param {function} fn the function to map * @returns {CrioArray} the mapped array */ map(fn) { return Array.prototype.map.call(this, (item, index) =&gt; { return getCrioedObject(fn(item, index, this)); }); } /** * @function merge * @memberof CrioArray * * @description * merge arrays with the original array * * @param {Array&lt;number|string&gt;|number|null} key the key to merge into * @param {...Array&lt;CrioArray&gt;} objects objects to merge with the crio * @returns {CrioArray} merged array */ merge(key, ...objects) { return objects.reduce((mergedObject, object) =&gt; { return merge(key, getCrioedObject(object), mergedObject); }, this); } /** * @function mutate * @memberof CrioArray * * @description * work with the array in a mutated way and return the crioed result of that call * * @param {function} fn function to apply to crio * @returns {*} crioed value resulting from the call */ mutate(fn) { return getCrioedObject(fn(this.thaw(), this)); } /** * @function pluck * @memberof CrioArray * * @description * get the values in each object in the collection at key, either shallow or deeply nested * * @param {string} key key to find value of in collection object * @returns {CrioArray} array of plucked values */ pluck(key) { const parsedKey = parse(key); const arrayToPluck = get(parsedKey.slice(0, parsedKey.length - 1), this); const finalKey = parsedKey.slice(-1); return arrayToPluck.map((item) =&gt; { return get(finalKey, item); }); } /** * @function pop * @memberof CrioArray * * @description * get crio based on current crio with last item removed * * @returns {CrioArray} array with the last value removed */ pop() { return this.slice(0, this.length - 1); } /** * @function push * @memberof CrioArray * * @description * push one to many items to the current crio * * @param {...Array&lt;*&gt;} items the items to add to the array * @returns {CrioArray} array with the values added */ push(...items) { return items.length ? this.concat(items) : this; } /** * @function reduce * @memberof CrioObject * * @description * reduce the crio down to a single value, starting with initial value * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @returns {*} the reduced value */ reduce(fn, initialValue) { return getCrioedObject( Array.prototype.reduce.call( this, (value, item, index) =&gt; { return fn(value, item, index, this); }, initialValue ) ); } /** * @function reduceRight * @memberof CrioObject * * @description * reduce the crio down to a single value, starting with initial value, starting from the end of the array * and iterating to the start * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @returns {*} the reduced value */ reduceRight(fn, initialValue) { return getCrioedObject( Array.prototype.reduceRight.call( this, (value, item, index) =&gt; { return fn(value, item, index, this); }, initialValue ) ); } /** * @function reverse * @memberof CrioArray * * @description * get the same values, but in reverse order * * @returns {CrioArray} array with the items reversed in order */ reverse() { return new CrioArray([...this].reverse()); } /** * @function set * @memberof CrioArray * * @description * set the value at the key passed * * @param {Array&lt;number|string&gt;|number} key key to assign value to * @param {*} value value to assign * @returns {CrioArray} array with value set at key */ set(key, value) { return set(key, getCrioedObject(value), this); } /** * @function shift * @memberof CrioArray * * @description * get crio based on current crio with first item removed * * @returns {CrioArray} array with the first item removed */ shift() { return this.slice(1); } /** * @function sort * @memberof CrioArray * * @description * sort the collection by the fn passed * * @param {function} fn the function to sort based on * @returns {CrioArray} array with the items sorted */ sort(fn) { const clone = [...this]; clone.sort(fn); return new CrioArray(clone); } /** * @function splice * @memberof CrioArray * * @description * splice the values into or out of the array * * @param {number} [start=0] starting index to splice * @param {number} [deleteCount=1] length from starting index to removes * @param {...Array&lt;*&gt;} items items to insert after delete is complete * @returns {CrioArray} array with the value spliced in / out */ splice(...args) { const clone = [...this]; clone.splice(...args); return new CrioArray(clone); } /** * @function thaw * @memberof CrioArray * * @description * create a plain JS version of the array * * @returns {Array&lt;*&gt;} plain JS version of the array */ thaw() { return thaw(this); } /** * @function toArray * @memberof CrioArray * * @description * convert the array to an array * * @returns {CrioArray} the array */ toArray() { return this; } /** * @function toLocaleString * @memberof CrioArray * * @description * convert the array to stringified form * * @param {function} [serializer] the serialization method to use * @param {number} [indent] the number of spaces to indent the values * @returns {string} stringified array */ toLocaleString(serializer, indent) { return this.toString(serializer, indent); } /** * @function toObject * @memberof CrioArray * * @description * convert the crio to an object if it isn't already * * @returns {CrioObject} new object from the array */ toObject() { return this.reduce((object, item, index) =&gt; { object[index] = item; return object; }, new CrioObject({})); } /** * @function toString * @memberof CrioArray * * @description * convert the array to stringified form * * @param {function} [serializer] the serialization method to use * @param {number} [indent] the number of spaces to indent the values * @returns {string} stringified array */ toString(serializer, indent) { return stringify(this, serializer, indent); } /** * @function unique * @memberof CrioArray * * @description * return the current CrioArray with the duplicate values removed * * @returns {CrioArray} new crio instance */ unique() { let hashArray = [], newArray = [], hasHashCode = false, hashCode, storeValue; return this.filter((item) =&gt; { hashCode = item ? item.hashCode : undefined; hasHashCode = !isUndefined(hashCode); storeValue = !~newArray.indexOf(item) &amp;&amp; (!hasHashCode || !~hashArray.indexOf(hashCode)); if (storeValue) { newArray.push(item); if (hasHashCode) { hashArray.push(hashCode); } } return storeValue; }); } /** * @function unshift * @memberof CrioArray * * @description * add items passed to the beginning of the crio array * * @param {...Array&lt;*&gt;} items items to prepend to the array * @returns {CrioArray} array with the items prepended */ unshift(...items) { return items.length ? new CrioArray([...items, ...this]) : this; } /** * @function valueOf * @memberof CrioArray * * @description * get the array value * * @returns {CrioArray} the array */ valueOf() { return this; } /** * @function values * @memberof CrioArray * * @description * get the values of the array as an array * * @returns {CrioArray} values in the array */ values() { return getValues(this); } /** * @function xor * @memberof CrioArray * * @description * find the values that are the symmetric difference of this and the arrays passed * * @param {Array&lt;Array&gt;} arrays arrays to find symmetric values in * @returns {CrioArray} array of the symmetric differences of all the arrays */ xor(...arrays) { if (!arrays.length) { return this; } let indicesToRemove = [], indexOfItem; const reducedItems = [this, ...arrays].reduce((items, array) =&gt; { if (isArray(array)) { array.forEach((item) =&gt; { indexOfItem = items.indexOf(item); if (~indexOfItem) { indicesToRemove.push(indexOfItem); } else { items = items.push(item); } }); } return items; }, new CrioArray([])); return reducedItems.filter((itemIgnored, index) =&gt; { return !~indicesToRemove.indexOf(index); }); } } export function applyPrototype() { Object.keys(ARRAY_FALLBACK_PROTOTYPE_METHODS).forEach((key) =&gt; { if (typeof Array.prototype[key] !== 'function') { CrioArray.prototype[key] = function(...args) { return ARRAY_FALLBACK_PROTOTYPE_METHODS[key](this, ...args); }; } }); if (typeof Symbol === 'function') { if (Symbol.species) { Object.defineProperty(CrioArray, Symbol.species, { configurable: false, enumerable: false, get() { return CrioArray; } }); } if (Symbol.iterator) { Object.defineProperty(CrioArray.prototype, Symbol.iterator, { configurable: false, enumerable: false, value: createIterator(), writable: false }); } if (Symbol.unscopables) { Object.defineProperty(CrioArray.prototype, Symbol.unscopables, { configurable: false, enumerable: false, value: ARRAY_UNSCOPABLES, writable: false }); } } } export default CrioArray; Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: utils.js // classes import CrioArray from './CrioArray'; import CrioObject from './CrioObject'; // is import {isArray, isCrio, isObject, isReactElement} from './is'; /** * @function createIterator * * @description * create a new iterator method * * @returns {function} the iterator method */ export const createIterator = () =&gt; { return function iterator() { const keys = this.keys(); const length = keys.length; let index = 0, value; return { next: () =&gt; { if (index &lt; length) { value = this[keys[index++]]; return { done: false, value }; } return { done: true }; } }; }; }; /** * @function every * * @description * does every result from calling fn match * * @param {CrioArray|CrioObject} object the object to test * @param {function} fn the function to perform the test on each item with * @returns {boolean} does every item match */ export const every = (object, fn) =&gt; { const objectKeys = object.keys(); let key; for (let index = 0; index &lt; objectKeys.length; index++) { key = objectKeys[index]; if (!fn(object[key], key, object)) { return false; } } return true; }; /** * @function find * * @description * find an item in the array if it exists * * @param {CrioArray|CrioObject} object the object to search * @param {function} fn function to test for finding the item * @param {boolean} [isKey] is the search for a key * @param {boolean} [isFromEnd] is the search for a key * @returns {*} found item or undefined */ export const find = (object, fn, isKey, isFromEnd) =&gt; { const objectKeys = isFromEnd ? object.keys().reverse() : object.keys(); let key; for (let index = 0; index &lt; objectKeys.length; index++) { key = objectKeys[index]; if (fn(object[key], key, object)) { return isKey ? key : object[key]; } } if (isKey) { return object.isArray() ? -1 : undefined; } return undefined; }; /** * @function getCrioedObject * * @description * get the object converted to a CrioArray or CrioObject, if applicable * * @param {*} object the object to potentially crio * @returns {*} either the crioed object, or the object itself */ export const getCrioedObject = (object) =&gt; { if (!object || typeof object !== 'object') { return object; } if (isArray(object)) { return object instanceof CrioArray ? object : new CrioArray(object); } return isObject(object) ? new CrioObject(object) : object; }; /** * @function getEntries * * @description * get the [key, value] pairs of the object * * @param {CrioArray|CrioObject} object the object to get the entries of * @returns {CrioArray} the entries of the object */ export const getEntries = (object) =&gt; { return object.keys().map((key) =&gt; { return [key, object[key]]; }); }; /** * @function getRelativeValue * * @description * get the relative value used in copyWithin * * @param {number} value value used as baseline * @param {number} length the length of the crio * @returns {number} the relative number value */ export const getRelativeValue = (value, length) =&gt; { return value &lt; 0 ? Math.max(length + value, 0) : Math.min(value, length); }; /** * @function getValues * * @description * get the values of the object * * @param {CrioArray|CrioObject} object the object to get the values of * @returns {CrioArray} the values of the object */ export const getValues = (object) =&gt; { return object.keys().map((key) =&gt; { return object[key]; }); }; /** * @function some * * @description * does any result from calling fn match * * @param {CrioArray|CrioObject} object the object to test * @param {function} fn the function to perform the test on each item with * @returns {boolean} does any item match */ export const some = (object, fn) =&gt; { const objectKeys = object.keys(); let key; for (let index = 0; index &lt; objectKeys.length; index++) { key = objectKeys[index]; if (fn(object[key], key, object)) { return true; } } return false; }; /** * @function thaw * * @description * convert the CrioArray or CrioObject passed to a plain JS object * * @param {CrioArray|CrioObject} object the object to convert * @returns {Array|Object} the plain JS version of the object passed */ export const thaw = (object) =&gt; { if (!isCrio(object)) { return object; } return object.isArray() ? [...object].map((item) =&gt; { return thaw(item); }) : Object.keys(object).reduce((reducedObject, key) =&gt; { reducedObject[key] = thaw(object[key]); return reducedObject; }, {}); }; Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: index.js // classes import CrioArray from './CrioArray'; import CrioObject from './CrioObject'; // is import {isArray, isCrio, isObject} from './is'; /** * @module crio */ /** * @function crio * * @description * build a new crio object based on the object passed * * @param {*} [object={}] object to convert to crio * * @returns {CrioArray|CrioObject} object that has been crioed */ const crio = (object = {}) =&gt; { if (isCrio(object)) { return object; } if (isArray(object)) { return new CrioArray(object); } if (isObject(object)) { return new CrioObject(object); } throw new TypeError('Object passed must be either an array or a plain object.'); }; /** * @function crio.array * * @description * convenience method for making crio arrays * * @param {Array&lt;*&gt;} array array to crio * @returns {CrioArray} crio array */ crio.array = (array = []) =&gt; { if (!isArray(array)) { throw new TypeError('Object passed must be an array.'); } return crio(array); }; /** * @function crio.isArray * * @description * check if object is a crio array * * @param {*} object object to test * @returns {boolean} is the object a crio array */ crio.isArray = (object) =&gt; { return isCrio(object) &amp;&amp; object.isArray(); }; crio.isCrio = isCrio; /** * @function crio.isObject * * @description * check if object is a crio object * * @param {*} object object to test * @returns {boolean} is the object a crio object */ crio.isObject = (object) =&gt; { return isCrio(object) &amp;&amp; object.isObject(); }; /** * @function crio.object * * @description * convenience method for making crio objects * * @param {Object} object object to crio * @returns {CrioObject} crio object */ crio.object = (object = {}) =&gt; { if (!isObject(object)) { throw new TypeError('Object passed must be a plain object.'); } return crio(object); }; export default crio; Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"CrioObject.js.html":{"id":"CrioObject.js.html","title":"Source: CrioObject.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: CrioObject.js // external dependencies import stringify from 'json-stringify-safe'; import {parse} from 'pathington'; import hashIt from 'hash-it'; import {get, has, merge, remove, set} from 'unchanged'; // classes import CrioArray from './CrioArray'; // constants import {OBJECT_UNSCOPABLES} from './constants'; // is import {isCrio, isEqual, isObject} from './is'; // utils import { createIterator, getCrioedObject, getEntries, getValues, every, find, some, thaw } from './utils'; let hasAppliedPrototype; class CrioObject { constructor(object) { const objectKeys = isObject(object) ? Object.keys(object) : []; if (!hasAppliedPrototype) { applyPrototype(); hasAppliedPrototype = true; } if (isCrio(object)) { return object.toObject(); } return objectKeys.reduce((crioObject, key) =&gt; { crioObject[key] = getCrioedObject(object[key]); return crioObject; }, this); } get hashCode() { return hashIt(this, true); } get size() { return Object.keys(this).length; } /** * @function clear * @memberof CrioObject * * @description * get a new crio that is empty * * @returns {CrioObject} an empty object */ clear() { return new CrioObject(); } /** * @function compact * @memberof CrioObject * * @description * get a new object with values from the original array that are truthy * * @returns {CrioObject} the object with only truthy values */ compact() { return this.filter((item) =&gt; { return !!item; }); } /** * @function delete * @memberof CrioObject * * @description * delete the value in the object at key, either shallow or deep * * @param {Array&lt;number|string&gt;|sring} key the key to delete * @returns {CrioObject} the array with the key deleted */ delete(key) { return remove(key, this); } /** * @function entries * @memberof CrioObject * * @description * get the pairs of [key, value] in the crio * * @returns {CrioArray} [key, value] pairs */ entries() { return getEntries(this); } /** * @function equals * @memberof CrioObject * * @description * does the object passed equal the crio * * @param {*} object object to compare against the instance * @returns {boolean} is the object equivalent in value */ equals(object) { return isEqual(this, object); } /** * @function every * @memberof CrioObject * * @description * does every instance in the object match * * @param {function} fn the function to test for matching * @returns {boolean} does every instance match */ every(fn) { return every(this, fn); } /** * @function filter * @memberof CrioObject * * @description * filter the object based on the fn passed * * @param {function} fn function to test for if it should be included in the result set * @returns {CrioObject} new crio instance */ filter(fn) { return new CrioObject( Object.keys(this).reduce((object, key) =&gt; { if (fn(this[key], key, object)) { object[key] = this[key]; } return object; }, {}) ); } /** * @function find * @memberof CrioObject * * @description * find an item in the crio if it exists * * @param {function} fn function to test for finding the item * @returns {*} found item or undefined */ find(fn) { return find(this, fn); } /** * @function findKey * @memberof CrioObject * * @description * find the key of an item in the crio if it exists * * @param {function} fn function to test for finding the item * @returns {number} index of match, or -1 */ findKey(fn) { return find(this, fn, true); } /** * @function findLast * @memberof CrioObject * * @description * find an item in the crio if it exists, starting from the end and iteratng to the start * * @param {function} fn function to test for finding the item * @returns {*} found item or undefined */ findLast(fn) { return find(this, fn, false, true); } /** * @function findLastKey * @memberof CrioObject * * @description * find the matching index based on truthy return from fn starting from end * * @param {function} fn function to use for test in iteration * @returns {number} index of match, or -1 */ findLastKey(fn) { return find(this, fn, true, true); } /** * @function forEach * @memberof CrioObject * * @description * iterate over the object calling fn * * @param {function} fn function to call in iteration * @returns {CrioObject} the original object */ forEach(fn) { Object.keys(this).forEach((key) =&gt; { fn(this[key], key, this); }); return this; } /** * @function get * @memberof CrioObject * * @description * get the item at key passed, either shallow or deeply nested * * @param {Array&lt;number|string&gt;|string} key key to retrieve * @returns {*} item found at key */ get(key) { return get(key, this); } /** * @function has * @memberof CrioObject * * @description * does the crio have the key passed, either shallow or deeply nested * * @param {Array&lt;number|string&gt;|string} key key to test * @returns {boolean} does the crio have the key */ has(key) { return has(key, this); } /** * @function includes * @memberof CrioObject * * @description * does the object have the item passed * * @param {*} item item to test for existence * @returns {boolean} does the item exist in the crio */ includes(item) { return this.some((value) =&gt; { return value === item; }); } /** * @function isArray * @memberof CrioObject * * @description * is the crio an array * * @returns {boolean} is the crio an array */ isArray() { return false; } /** * @function isObject * @memberof CrioObject * * @description * is the crio an object * * @returns {boolean} is the crio an object */ isObject() { return true; } /** * @function keyOf * @memberof CrioObject * * @description * get the key for the item passed * * @param {*} item the item to search for * @returns {string} the key of match, or undefined */ keyOf(item) { return this.findKey((value) =&gt; { return value === item; }); } /** * @function keys * @memberof CrioObject * * @description * get the keys of the crio * * @returns {CrioArray&lt;string&gt;} keys in the crio */ keys() { return new CrioArray(Object.keys(this)); } /** * @function lastKeyOf * @memberof CrioObject * * @description * get the key for the item passed, starting from the end of the array and iterating towards the start * * @param {*} item the item to search for * @returns {string} the key of match, or undefined */ lastKeyOf(item) { return this.findLastKey((value) =&gt; { return value === item; }); } /** * @function map * @memberof CrioObject * * @description * iterate over the object mapping the result of fn to the key * * @param {function} fn function to call on iteration * @returns {Crio} the mapped object */ map(fn) { return Object.keys(this).reduce((object, key) =&gt; { object[key] = getCrioedObject(fn(this[key], key, this)); return object; }, new CrioObject({})); } /** * @function merge * @memberof CrioObject * * @description * merge objects with the original object * * @param {Array&lt;number|string&gt;|number|null} key the key to merge into * @param {...Array&lt;CrioObject&gt;} objects objects to merge with the crio * @returns {CrioObject} new crio instance */ merge(key, ...objects) { return objects.reduce((mergedObject, object) =&gt; { return merge(key, getCrioedObject(object), mergedObject); }, this); } /** * @function mutate * @memberof CrioObject * * @description * work with the object in a mutated way and return the crioed result of that call * * @param {function} fn function to apply to crio * @returns {*} crioed value resulting from the call */ mutate(fn) { return getCrioedObject(fn(this.thaw(), this)); } /** * @function pluck * @memberof CrioObject * * @description * get the values in each object in the collection at key, either shallow or deeply nested * * @param {string} key key to find value of in collection object * @returns {CrioArray} array of plucked values */ pluck(key) { const parsedKey = parse(key); const objectToPluck = get(parsedKey.slice(0, parsedKey.length - 1), this); const finalKey = parsedKey.slice(-1); return objectToPluck .map((item) =&gt; { return get(finalKey, item); }) .values(); } /** * @function reduce * @memberof CrioObject * * @description * reduce the crio down to a single value, starting with initial value * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @returns {*} the reduced value */ reduce(fn, initialValue) { return getCrioedObject( Object.keys(this).reduce((value, key) =&gt; { return fn(value, this[key], key, this); }, initialValue) ); } /** * @function reduceRight * @memberof CrioObject * * @description * reduce the crio down to a single value, starting with initial value, starting from the end of the array * and iterating to the start * * @param {function} fn the function to iterate with * @param {*} initialValue the initial value of the reduction * @returns {*} the reduced value */ reduceRight(fn, initialValue) { return getCrioedObject( Object.keys(this) .reverse() .reduce((value, key) =&gt; { return fn(value, this[key], key, this); }, initialValue) ); } /** * @function set * @memberof CrioObject * * @description * set the value at the key passed * * @param {Array&lt;number|string&gt;|string} key key to assign value to * @param {*} value value to assign * @returns {CrioObject} object with value set at key */ set(key, value) { return set(key, getCrioedObject(value), this); } /** * @function some * @memberof CrioObject * * @description * does any item in the object match the result from fn * * @param {function} fn the function to test for matching * @returns {boolean} does any item match */ some(fn) { return some(this, fn); } /** * @function sort * @memberof CrioObject * * @description * sort the collection by the fn passed * * @param {function} fn the function to sort based on * @returns {CrioObject} object with the items sorted */ sort(fn) { return new CrioObject( Object.keys(this) .sort(fn) .reduce((object, key) =&gt; { object[key] = this[key]; return object; }, {}) ); } /** * @function thaw * @memberof CrioObject * * @description * create a plain JS version of the object * * @returns {Object} plain JS version of the object */ thaw() { return thaw(this); } /** * @function toArray * @memberof CrioObject * * @description * convert the object to an array * * @returns {CrioArray} the object converted to an array of its values */ toArray() { return this.values(); } /** * @function toLocaleString * @memberof CrioObject * * @description * convert the object to stringified form * * @param {function} [serializer] the serialization method to use * @param {number} [indent] the number of spaces to indent the values * @returns {string} stringified object */ toLocaleString(serializer, indent) { return this.toString(serializer, indent); } /** * @function toObject * @memberof CrioObject * * @description * convert the object to an objectobject * * @returns {CrioObject} the object */ toObject() { return this; } /** * @function toString * @memberof CrioObject * * @description * convert the object to stringified form * * @param {function} [serializer] the serialization method to use * @param {number} [indent] the number of spaces to indent the values * @returns {string} stringified object */ toString(serializer, indent) { return stringify(this, serializer, indent); } /** * @function valueOf * @memberof CrioObject * * @description * get the object value * * @returns {CrioObject} the object */ valueOf() { return this; } /** * @function values * @memberof CrioObject * * @description * get the values of the object as an array * * @returns {CrioObject} values in the object */ values() { return getValues(this); } } export function applyPrototype() { if (typeof Symbol === 'function') { if (Symbol.species) { Object.defineProperty(CrioObject, Symbol.species, { configurable: false, enumerable: false, get() { return CrioObject; } }); } if (Symbol.iterator) { Object.defineProperty(CrioObject.prototype, Symbol.iterator, { configurable: false, enumerable: false, value: createIterator(), writable: false }); } if (Symbol.unscopables) { Object.defineProperty(CrioObject.prototype, Symbol.unscopables, { configurable: false, enumerable: false, value: OBJECT_UNSCOPABLES, writable: false }); } } } export default CrioObject; Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"is.js.html":{"id":"is.js.html","title":"Source: is.js","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Source: is.js // classes import CrioArray from './CrioArray'; import CrioObject from './CrioObject'; // constants import {REACT_ELEMENT_TYPE} from './constants'; /** * @function isArray * * @description * is the object passed an array * * @param {*} object the object to test * @returns {boolean} is the object an array */ export const isArray = Array.isArray; /** * @function isCrio * * @description * is the object passed a CrioArray or CrioObject * * @param {*} object the object to test * @returns {boolean} is the object a Crio* */ export const isCrio = (object) =&gt; { return object instanceof CrioArray || object instanceof CrioObject; }; /** * @function isEqual * * @description * are the crio objects equal * * @param {CrioArray|CrioObject} crio crio object to test against * @param {*} object object to test equality with crio object for * @returns {boolean} are the objects equal */ export const isEqual = (crio, object) =&gt; { return isCrio(object) &amp;&amp; crio.hashCode === object.hashCode; }; /** * @function isFunction * * @description * is the object passed a function * * @param {*} object the object to test * @returns {boolean} is the object a function */ export const isFunction = (object) =&gt; { return typeof object === 'function'; }; /** * @function isNumber * * @description * is the object passed a number * * @param {*} object the object to test * @returns {boolean} is the object a number */ export const isNumber = (object) =&gt; { return typeof object === 'number'; }; /** * @function isReactElement * * @description * is the object passed a react element * * @param {*} object the object to test * @returns {boolean} is the object a react element */ export const isReactElement = (object) =&gt; { return !!object &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE; }; /** * @function isObject * * @description * is the object passed a plain object * * @param {*} object the object to test * @returns {boolean} is the object a plain object */ export const isObject = (object) =&gt; { return !!object &amp;&amp; object.constructor === Object &amp;&amp; !isReactElement(object); }; /** * @function isString * * @description * is the object passed a string * * @param {*} object the object to test * @returns {boolean} is the object a string */ export const isString = (object) =&gt; { return typeof object === 'string'; }; /** * @function isUndefined * * @description * is the object passed undefined * * @param {*} object the object to test * @returns {boolean} is the object undefined */ export const isUndefined = (object) =&gt; { return object === void 0; }; Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Global Members &lt;constant&gt; ARRAY_FALLBACK_PROTOTYPE_METHODS :Object Type: Object Source: constants.js, line 23 &lt;constant&gt; ARRAY_UNSCOPABLES :Object Type: Object Source: constants.js, line 8 &lt;constant&gt; ARRAY_UNSCOPABLES :Object Type: Object Source: constants.js, line 98 &lt;constant&gt; REACT_ELEMENT_TYPE :Symbol|number Type: Symbol | number Source: constants.js, line 115 Methods copyWithin(targetIndex [, startIndex] [, endIndex]) move values around within the array Parameters: Name Type Argument Default Description targetIndex number target to copy startIndex number &lt;optional&gt; 0 index to start copying to endIndex number &lt;optional&gt; this.length index to stop copying to Source: CrioArray.js, line 138 Returns: array with target copied in appropriate spots Type CrioArray createIterator() create a new iterator method Source: utils.js, line 24 Returns: the iterator method Type function every(object, fn) does every result from calling fn match Parameters: Name Type Description object CrioArray | CrioObject the object to test fn function the function to perform the test on each item with Source: utils.js, line 61 Returns: does every item match Type boolean every(fn) does every instance in the array match Parameters: Name Type Description fn function the function to test for matching Source: constants.js, line 28 Returns: does every instance match Type boolean fill(value [, startIndex] [, endIndex]) fill the array at certain indices with the value passed Parameters: Name Type Argument Default Description value * the value to fill the indices with startIndex number &lt;optional&gt; 0 the starting index to fill endIndex number &lt;optional&gt; this.length the ending index to fill Source: CrioArray.js, line 272 Returns: array with values filled appropriately Type CrioArray find(object, fn [, isKey] [, isFromEnd]) find an item in the array if it exists Parameters: Name Type Argument Description object CrioArray | CrioObject the object to search fn function function to test for finding the item isKey boolean &lt;optional&gt; is the search for a key isFromEnd boolean &lt;optional&gt; is the search for a key Source: utils.js, line 87 Returns: found item or undefined Type * find(fn) find an item in the array if it exists Parameters: Name Type Description fn function function to test for finding the item Source: constants.js, line 42 Returns: found item or undefined Type * findIndex(fn) find the index of an item in the array if it exists Parameters: Name Type Description fn function function to test for finding the item Source: constants.js, line 56 Returns: index of match, or -1 Type number getCrioedObject(object) get the object converted to a CrioArray or CrioObject, if applicable Parameters: Name Type Description object * the object to potentially crio Source: utils.js, line 119 Returns: either the crioed object, or the object itself Type * getEntries(object) get the [key, value] pairs of the object Parameters: Name Type Description object CrioArray | CrioObject the object to get the entries of Source: utils.js, line 140 Returns: the entries of the object Type CrioArray getRelativeValue(value, length) get the relative value used in copyWithin Parameters: Name Type Description value number value used as baseline length number the length of the crio Source: utils.js, line 155 Returns: the relative number value Type number getValues(object) get the values of the object Parameters: Name Type Description object CrioArray | CrioObject the object to get the values of Source: utils.js, line 169 Returns: the values of the object Type CrioArray includes(item) does the array have the item passed Parameters: Name Type Description item * item to test for existence Source: constants.js, line 70 Returns: does the item exist in the array Type boolean isArray(object) is the object passed an array Parameters: Name Type Description object * the object to test Source: is.js, line 18 Returns: is the object an array Type boolean isCrio(object) is the object passed a CrioArray or CrioObject Parameters: Name Type Description object * the object to test Source: is.js, line 29 Returns: is the object a Crio* Type boolean isEqual(crio, object) are the crio objects equal Parameters: Name Type Description crio CrioArray | CrioObject crio object to test against object * object to test equality with crio object for Source: is.js, line 46 Returns: are the objects equal Type boolean isFunction(object) is the object passed a function Parameters: Name Type Description object * the object to test Source: is.js, line 60 Returns: is the object a function Type boolean isNumber(object) is the object passed a number Parameters: Name Type Description object * the object to test Source: is.js, line 73 Returns: is the object a number Type boolean isObject(object) is the object passed a plain object Parameters: Name Type Description object * the object to test Source: is.js, line 99 Returns: is the object a plain object Type boolean isReactElement(object) is the object passed a react element Parameters: Name Type Description object * the object to test Source: is.js, line 86 Returns: is the object a react element Type boolean isString(object) is the object passed a string Parameters: Name Type Description object * the object to test Source: is.js, line 112 Returns: is the object a string Type boolean isUndefined(object) is the object passed undefined Parameters: Name Type Description object * the object to test Source: is.js, line 125 Returns: is the object undefined Type boolean some(fn) does any item in the array match the result from fn Parameters: Name Type Description fn function the function to test for matching Source: constants.js, line 84 Returns: does any item match Type boolean some(object, fn) does any result from calling fn match Parameters: Name Type Description object CrioArray | CrioObject the object to test fn function the function to perform the test on each item with Source: utils.js, line 184 Returns: does any item match Type boolean thaw(object) convert the CrioArray or CrioObject passed to a plain JS object Parameters: Name Type Description object CrioArray | CrioObject the object to convert Source: utils.js, line 210 Returns: the plain JS version of the object passed Type Array | Object Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Modules Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Tutorials Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw crio 4.1.2 crio Immutable JS objects with a natural API Jump to the API API Documentation Upgrade notice If upgrading from 4.x.x and earlier versions, please check the changelog for breaking changes. Import // ES2015 import crio from 'crio'; // CommonJS const crio = require('crio').default; // UMD const crio = window.crio;Usage // you can assign with crio() directly const crioArray = crio(['foo']); const updatedCrioArray = crioArray.push('bar'); const crioObject = crio({foo: 'bar'}); const updatedCrioObject = crioObject.set('bar', 'baz'); // or use the convenience methods const otherCrioArray = crio.array(['bar']); const updatedOtherCrioArray = otherCrioArray.push('bar'); const otherCrioObject = crio.object({bar: 'baz'}); const updatedOtherCrioObject = otherCrioObject.set('bar', 'baz');What is immutable? When something is described as immutable, it means that it cannot change after it has been created. In JavaScript terms, this means that any attempted change to an object results in a brand new object being created, without changing the original object. Why is this helpful? The concept of immutability already exists in a lot of places in JavaScript, for example: const two = 2; const three = 3; const five = two + three;By adding together two and three you expect to get five, however you don't expect the value of two to change. You can continue working with it even after using it in an expression: const two = 2; const three = 3; const five = two + three; const four = two * two;This is true of strings, numbers, undefined, and null, and is an expected behavior. The same idea, however, is not true for complex objects in JavaScript. For example: const foo = ['foo']; const fooBar = foo.push('bar');The expectation is that you have pushed the value of &quot;bar&quot; into foo and created a new array bar that contains &quot;foo, bar&quot;, however in reality this is what happens: const foo = ['foo']; const fooBar = foo.push('bar'); console.log(foo); // ['foo', 'bar'] console.log(fooBar); // 1Basically, you have mutated foo so that it is no longer empty, and what the .push() method returns is actually the index of the item you just added. This double-standard of expectations creates a lot confusion from a development perspective, but also makes keeping track of the state of your application very difficult because there is no traceability of what transactions have occurred to create that state at any given point. This can create a lot of difficult-to-diagnose bugs and potential future regression points. Enter crio crio attempts to solve the problem by closing the &quot;immutable loop&quot; on collection items, meaning it applies immutability to objects that are normally mutable by nature by replacing mutating methods with immutable counterparts. As a point of reference: Naturally immutable objects Numbers Strings undefined null Naturally mutable objects Arrays Dates (not covered by crio) Objects The API is the same as you already know working with those objects, as well as several helpful crio-specific functions. You can work with the objects as you normally would with other libraries (lodash, for example) with the exception that any setting happens via .set() rather than direct index / property setting. There is also no change to the protoypes of native objects, so you can apply this on your existing code go-forward. Basically, you shouldn't even notice you aren't working with the native objects, save for the fact everything is immutable. Why not just use X immutable library? immutable is quite nice, and very highly regarded by the community, however it creates an opaque object that cannot be used with other external libraries (namely lodash) without converting back to vanilla JS. This lack of interoperability creates a lot of hoops to jump through at certain points of development, and also trains you to not necessarily think in JS, but in the library. seamless-immutable has some great ideas, but they do not try to replace mutable methods with immutable ones, they just throw errors when you attempt them and its up to you to figure out the &quot;right way&quot;. Also, it can be quite slow for certain operations. Bottom line, I support each of these projects because they are trying to instill immutability in JavaScript practices, but I took a different approach that I consider the best of both worlds. :) Browser support Chrome (all versions) Firefox (all versions) Edge (all versions) Opera 15+ IE 11+ Safari 8+ iOS 8+ Android 4+ Node support 4+ Gotchas Recursive objects are not allowed Immutable objects with recursive values are basically impossible, and trying them will cause a stack overflow, so be mindful of that! Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: benchmark =&gt; run benchmarks in node benchmark:watch =&gt; run benchmark with persistent watcher for changes build =&gt; run webpack to build crio.js with NODE_ENV=development build:minifed =&gt; run webpack to build crio.min.js with NODE_ENV=production compile-for-publish =&gt; run lint, test, transpile, dist dev =&gt; run webpack dev server to run example app (playground!) dev:production =&gt; runs dev but with NODE_ENV=production dist =&gt; runs build and build-minified lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish test =&gt; run AVA test functions with NODE_ENV=test test:watch =&gt; same as test, but runs persistent watcher transpile =&gt; run babel against all files in src to create files in lib Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-crio.html":{"id":"module-crio.html","title":"Module: crio","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw Module: crio Source: index.js, line 17 Methods &lt;inner&gt; crio( [object]) build a new crio object based on the object passed Parameters: Name Type Argument Default Description object * &lt;optional&gt; {} object to convert to crio Source: index.js, line 21 Returns: object that has been crioed Type CrioArray | CrioObject Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"tutorial-API.html":{"id":"tutorial-API.html","title":"Tutorial: API","body":" crio Modules crio Tutorials API Global ARRAY_FALLBACK_PROTOTYPE_METHODSARRAY_UNSCOPABLEScopyWithincreateIteratoreveryfillfindfindIndexgetCrioedObjectgetEntriesgetRelativeValuegetValuesincludesisArrayisCrioisEqualisFunctionisNumberisObjectisReactElementisStringisUndefinedREACT_ELEMENT_TYPEsomethaw API crio API Instantiation crio(object: any): (CrioArray|CrioObject) Standard method, will crio the object passed if an array or object, else it will return the object itself const emptyObject = crio(); // {} const populatedObject = crio({foo: 'bar'}); // {foo: 'bar'} const populatedArray = crio(['foo', 'bar']); // ['foo', 'bar'] crio.array(object: Array&lt;any&gt;): CrioArray Shortcut method for crioing array-specific values const empty = crio.array(); // [] const populated = crio.array(['foo']); // ['foo'] crio.object(object: Object): CrioObject Shortcut method for crioing object-specific values const empty = crio.object(); // {} const populated = crio.object({foo: 'bar'}); // {foo: 'bar'} crio.isCrio(object: any): boolean Determine if the object passed is a Crio const normal = {foo: 'bar'}; const crioed = crio({foo: 'bar'}); console.log(crio.isCrio(normal)); // false console.log(crio.isCrio(crioed)); // true crio.isArray(object: any): boolean Determine if the object passed is a CrioArray const normal = ['foo']; const croiedArray = crio(['foo']); const crioedObject = crio({foo: 'bar'}); console.log(crio.isObject(normal)); // false console.log(crio.isObject(croiedArray)); // true console.log(crio.isObject(crioedObject)); // false crio.isObject(object: any): boolean Determine if the object passed is a CrioObject const normal = {foo: 'bar'}; const croiedArray = crio(['foo']); const crioedObject = crio({foo: 'bar'}); console.log(crio.isObject(normal)); // false console.log(crio.isObject(croiedArray)); // false console.log(crio.isObject(crioedObject)); // trueMethods with the same name as the native method will be a link to MDN, as they are meant to be as similar to the native method as possible, with the exception of accepting thisArg. Where any specific differences from the default behavior exist, the crio-specific behavior is mentioned. Arrays clear(): CrioArray returns an empty CrioArray const populated = crio(['foo']); console.log(populated.clear()); // [] compact(): CrioArray returns a new CrioArray with all falsy values filtered out const array = crio(['foo', false, 0, '', {}, [], null, undefined]); console.log(array.compact()); // ['foo', {}, []] concat const array = crio(['foo']); console.log(array.concat(['bar'])); // ['foo', 'bar'] delete(key: (Array&lt;number|string&gt;|number)): CrioArray Deletes the key provided from the CrioArray Supports shallow or deep values via array or dot-bracket syntax const array = crio(['foo', {bar: 'baz', baz: 'quz'}]); console.log(array.delete(1)); // ['foo'] console.log(array.delete('[1].bar')); // ['foo', {baz: 'quz'}] difference(array1: Array&lt;any&gt;[, array2: Array&lt;any&gt;[, ...arrayN: Array&lt;any&gt;]]): CrioArray Returns a new array of the values that only exist in either the CrioArray or in one of the arrays passed const array = crio(['foo', true, 1]); console.log(array.difference(['foo'], [true])); // [1] copyWithin const array = crio(['foo', 'bar', 'baz']); console.log(array.copyWithin(2, 0)); // ['foo', 'bar', 'foo'] entries const array = crio(['foo', 'bar']); console.log(array.entries()); // [[0, 'foo'], [1, 'bar']] equals(object: any): boolean Determines whether object is deeply equal to the CrioArray const array = crio(['foo']); const matchingArray = crio(['foo']); console.log(array === matchingArray); // false console.log(array.equals(matchingArray)); // true console.log(array.equals(crio(['bar']))); // false every const array = crio(['foo', 'bar']); console.log(array.every(value =&gt; value.length === 3)); // true console.log(array.every(value =&gt; value === 'bar')); // false fill Returns new CrioArray with items from start to end filled with value const array = crio(['foo', 'bar', 'baz']); console.log(array.fill('same')); // ['same', 'same', 'same'] filter const array = crio(['foo', 'bar', 'baz']); console.log(array.filter(value =&gt; value[0] === 'b')); // ['bar', 'baz'] find const array = crio(['foo', 'bar', 'baz']); console.log(array.find(value =&gt; value[0] === 'b')); // 'bar' findIndex const array = crio(['foo', 'bar', 'baz']); console.log(array.find(value =&gt; value[0] === 'b')); // 1 findLast(fn: function(value: any, index: number, object: CrioArray)): any Find the value that matches the result of fn starting at the last index in the object const array = crio(['foo', 'bar', 'baz']); console.log(array.find(value =&gt; value[0] === 'b')); // 'baz' findLastIndex(fn: function): number Same as findIndex but starting from end and working to start const array = crio(['foo', 'bar', 'baz']); console.log(array.find(value =&gt; value[0] === 'b')); // 2 first(size: number = 1): CrioArray Returns a new array of the first size number of items in the array const array = crio(['foo', 'bar', 'baz']); console.log(array.first()); // ['foo'] console.log(array.first(2)); // ['foo', 'bar'] forEach const array = crio(['foo', 'bar']); let count = 0; console.log(array.forEach(() =&gt; count++)); // ['foo', 'bar'] console.log(count); // 2 get(key: (Array&lt;number|string&gt;|number)): any Retrieve value at key Supports shallow or deep values via array or dot-bracket syntax const array = crio(['foo', {bar: 'baz'}]); console.log(array.get(1)); // {bar: 'baz'} console.log(array.get('[1].bar')); // 'baz' has(key: (Array&lt;number|string&gt;|number)): boolean Does key exist in object Supports shallow or deep values via array or dot-bracket syntax const array = crio(['foo', {bar: 'baz'}]); console.log(array.has(1)); // true console.log(array.has(6)); // false console.log(array.has('[1].bar')); // true console.log(array.has('[1].quz')); // false includes const array = crio(['foo', 'bar']); console.log(array.includes('foo')); // true console.log(array.includes('baz')); // false intersection(array1: Array&lt;any&gt;[, array2: Array&lt;any&gt;[, ...arrayN: Array&lt;any&gt;]]): CrioArray Returns a new CrioArray of the values that exist in all of the arrays const array = crio(['foo', 1, true]); console.log(array.intersection(['foo', 1], [1])); // 1 indexOf const array = crio(['foo', 'bar', 'baz', 'bar']); console.log(array.indexOf('bar')); // 1 join const array = crio(['foo', 'bar']); console.log(array.join()); // 'foo,bar' console.log(array.join('|')); // 'foo|bar' keys const array = crio(['foo', 'bar']); console.log(array.keys()); // [0, 1] last(size: number = 1): CrioArray Returns a new CrioArray of the last num number of items in the array const array = crio(['foo', 'bar', 'baz']); console.log(array.last()); // ['baz'] console.log(array.last(2)); // ['bar', 'baz'] lastIndexOf const array = crio(['foo', 'bar', 'baz', 'bar']); console.log(array.indexOf('bar')); // 3 map const array = crio(['foo', 'bar']); console.log( array.map(value =&gt; value .slice('') .reverse() .join('') ) ); // ['oof', 'rab'] merge(array1: Array&lt;any&gt;[, array2: Array&lt;any&gt;[, ...arrayN: Array&lt;any&gt;]]): CrioArray Merge any number of objects into existing crio Supports shallow or deep key values via array or dot-bracket syntax const array = crio(['foo', {bar: 'baz'}]); console.log(array.merge(null, ['quz'])); // ['foo', {bar: 'baz'}, 'quz'] console.log(array.merge('[0].bar', {baz: 'quz'})); // ['foo', {bar: {baz: 'quz'}}] mutate(fn: function(array: Array&lt;any&gt;, crio: CrioArray)): any Whatever you return in the callback is what is returned (as a CrioArray or CrioObject if applicable) const array = crio([{foo: 'bar'}]); const result = array.mutate(thawed =&gt; { thawed[0].foo = 'baz'; thawed.push('bar'); return thawed; }); console.log(result); // [{foo: 'baz'}, 'bar'] pluck(key: (Array&lt;number|string&gt;|number)): CrioArray Iterates over the CrioArray and returns a new CrioArray of values where the key exists as a property on the collection item Supports shallow or deep values via array or dot-bracket syntax const array = crio([{foo: 'bar'}, {bar: 'baz'}, {foo: 'quz'}]); console.log(array.pluck('foo')); // ['bar', undefined, 'quz'] const deepArray = crio([ [{foo: 'foo'}, {bar: 'baz'}, {foo: 'bar'}], [{foo: 'bar'}, {bar: 'baz'}, null, {foo: 'foo'}] ]); console.log(array.pluck('[1].foo')); // ['bar', undefined, undefined, 'foo'] pop Returns new CrioArray with first item removed const array = crio(['foo', 'bar']); console.log(array.pop()); // ['foo'] push Returns new CrioArray with new item(s) added const array = crio(['foo']); console.log(array.push('bar', 'baz')); // ['foo', 'bar', 'baz'] reduce const array = crio([1, 2, 3]); const result = array.reduce( ({order, sum}, value) =&gt; { return {order: [...order, value], sum: sum + value}; }, {order: [], sum: 0} ); console.log(result); // {order: [1, 2, 3], sum: 6} reduceRight const array = crio([1, 2, 3]); const result = array.reduceRight( ({order, sum}, value) =&gt; { return {order: [...order, value], sum: sum + value}; }, {order: [], sum: 0} ); console.log(result); // {order: [3, 2, 1], sum: 6} reverse The original array's order is maintained (not mutated) const array = crio(['foo', 'bar', 'baz']); console.log(array.reverse()); // ['baz', 'bar', 'foo'] set(key: (Array&lt;number|string&gt;|number), value: any): CrioArray Sets value at key Supports shallow or deep values via array or dot-bracket syntax const array = crio(['foo', {bar: 'baz'}]); console.log(array.set(1, 'quz')); // ['foo', 'quz'] console.log(array.set('[1].bar', 'quz')); // ['foo', {bar: 'quz'}] shift Returns new CrioArray with first item removed const array = crio(['foo', 'bar', 'baz']); console.log(array.shift()); // ['bar', 'baz'] slice const array = crio(['foo', 'bar']); console.log(array.slice(1)); // ['bar'] some const array = crio(['foo', 'bar', 'baz']); console.log(array.some(value =&gt; value === 'bar')); // true console.log(array.some(value =&gt; value === 'quz')); // false sort Returns new CrioArray sorted by either callback or default const array = crio(['foo', 'bar', 'baz']); console.log(array.sort()); // ['bar', 'baz', 'foo'] splice Returns new CrioArray with item(s) added/removed based on splicing parameters const array = crio(['foo', 'bar', 'baz']); console.log(array.splice(1, 1)); // ['foo', 'baz'] thaw(): Array&lt;any&gt; Recursively thaws CrioArray deeply and returns standard array version of itself const array = crio(['foo', 'bar']); console.log(array.thaw()); // ['foo', 'bar'] console.log(array.constructor === Array); // false console.log(array.thaw().constructor === Array); // true toObject(): CrioObject Converts CrioArray into a CrioObject of {index: value} pairs const array = crio(['foo', 'bar']); console.log(array.toObject()); // {0: 'foo', 1: 'bar'} toLocaleString Returns stringified version of CrioArray Optionally accepts serializer and indent arguments, which are identical to those arguments for JSON.stringify const array = crio(['foo', 'bar']); console.log(array.toLocaleString()); // [&quot;foo&quot;,&quot;bar&quot;] console.log(arrat.toLocaleString(null, 2)); /* [ &quot;foo&quot;, &quot;bar&quot; ] */ toString Returns stringified version of CrioArray Optionally accepts serializer and indent arguments, which are identical to those arguments for JSON.stringify const array = crio(['foo', 'bar']); console.log(array.toString()); // [&quot;foo&quot;,&quot;bar&quot;] console.log(arrat.toString(null, 2)); /* [ &quot;foo&quot;, &quot;bar&quot; ] */ unique(): CrioArray Returns a new CrioArray of values filtered down to only existing in the array once const array = crio(['foo', 'bar', 'foo', 'foo', 'bar']); console.log(array.unique()); // ['foo', 'bar'] unshift Returns new CrioArray with new item(s) added to beginning const array = crio(['foo', 'bar']); console.log(array.unshift('baz', 'quz')); // ['baz', 'quz', 'foo', 'bar'] values const array = crio(['foo', 'bar']); console.log(array.values()); // ['foo', 'bar'] xor(array1: Array&lt;any&gt;[, array2: Array&lt;any&gt;[, ...arrayN: Array&lt;any&gt;]]): CrioArray Returns a new CrioArray of the values that are the symmetric difference of the CrioArray and the arrays passed const array = crio(['foo', 1, true]); console.log(array.xor(['foo'], [true])); // [1]Objects clear(): CrioObject returns an empty CrioObject const object = crio({foo: 'bar'}); console.log(object.clear()); compact(): CrioObject returns a new CrioObject with all falsy values filtered out const object = crio({ string: 'foo', bool: false, num: 0, object: {}, array: [], nul: null, undef: undefined }); console.log(object.compact()); // {string: 'foo', object: {}, array: []} delete(key: (Array&lt;number|string&gt;|string)): CrioObject Deletes the key provided from the CrioObject Supports shallow or deep values via array or dot-bracket syntax const object = crio({foo: 'bar', bar: ['baz', 'quz']}); console.log(object.delete('bar')); // {foo; 'bar'} console.log(object.delete('bar[0]')); // {foo: 'bar', bar: ['quz']} entries(): CrioArray Gets an array of the [key, value] pairs in the CrioObject const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.entries()); // [['foo', 'bar'], ['bar', 'baz']] every(fn: function(value: any, key: string, object: CrioObject)): boolean Performs same function as every in CrioArray, but on the CrioObject const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.every(value =&gt; value.length === 3)); // true console.log(object.every(value =&gt; value === 'bar')); // false forEach(fn: function(value: any, key: string, object: CrioObject)): CrioObject Iterates over object executing fn and returns the original CrioObject Iteration order is not guaranteed (due to object key order not being guaranteed per the spec) const object = crio({foo: 'bar', bar: 'baz'}); let count = 0; console.log(object.forEach(() =&gt; count++)); // {foo: 'bar', bar: 'baz'} console.log(count); // 2 filter(fn: function(value: any, key: string, object: CrioObject)): CrioObject Iterates over object and filters out any returned values that are falsy Iteration order is not guaranteed (due to object key order not being guaranteed per the spec) const object = crio({foo: 'bar', bar: 'baz', baz: 'quz'}); console.log(object.filter(value =&gt; value[0] === 'b')); // {foo: 'bar', bar: 'baz'} find(fn: function(value: any, key: string, object: CrioObject)): any Same as find for CrioArray but on the CrioObject const object = crio({foo: 'bar', bar: 'baz'}, (baz: 'quz')); console.log(object.find(value =&gt; value !== 'baz')); // 'bar' findKey(fn: function(value: any, key: string, object: CrioObject)): string Same as findIndex for CrioArray but finding the appropriate key const object = crio({foo: 'bar', bar: 'baz'}, (baz: 'quz')); console.log(object.findKey(value =&gt; value !== 'baz')); // 'foo' findLast(fn: function(value: any, key: string, object: CrioObject)): any Find the value that matches the result of fn starting at the last key in the CrioObject const object = crio({foo: 'bar', bar: 'baz'}, (baz: 'quz')); console.log(object.findLast(value =&gt; value !== 'baz')); // 'quz' findLastKey(fn: function(value: any, key: string, object: CrioObject)): string Same as findKey but starting from end and working to start const object = crio({foo: 'bar', bar: 'baz'}, (baz: 'quz')); console.log(object.findLastKey(value =&gt; value !== 'baz')); // 'baz' get(key: (Array&lt;number|string&gt;|string)): any Retrieve value at key Supports shallow or deep values via array or dot-bracket syntax const object = crio({foo: 'bar', bar: ['baz', 'quz']}); console.log(crio.get('bar')); // ['baz', 'quz'] console.log(crio.get('bar[0]')); // 'baz' has(key: (Array&lt;number|string&gt;|string)): boolean Does key exist in object Supports shallow or deep values via array or dot-bracket syntax const object = crio({foo: 'bar', bar: ['baz', 'quz']}); console.log(crio.has('bar')); // true console.log(crio.has('baz')); // false console.log(crio.has('bar[0]')); // true console.log(crio.has('bar[6]')); // false hasOwnProperty Only supports shallow values const object = crio({foo: 'bar', bar: ['baz', 'quz']}); console.log(crio.hasOwnProperty('bar')); // true console.log(crio.hasOwnProperty('baz')); // false includes(item: any): boolean Determine if the CrioObject has a value that matches value in strict equality const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.includes('baz')); // true console.log(object.includes('quz')); // false keyOf(item: any): string Get the key for the item passed starting with the first key in the CrioObject const object = crio({foo: 'bar', bar: 'baz', baz: 'bar'}); console.log(object.keyOf('bar')); // foo keys(): CrioArray Returns an array of the keys in the CrioObject const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.keys()); // ['foo', 'bar'] lastKeyOf(item: any): string Get the key for the item passed starting with the last key in the CrioObject const object = crio({foo: 'bar', bar: 'baz', baz: 'bar'}); console.log(object.keyOf('bar')); // baz map(fn: function(value: any, key: string, object: CrioObject)): CrioObject Iterates over object and maps returned value to the respective key Iteration order is not guaranteed (due to object key order not being guaranteed per the spec) const object = crio({foo: 'bar', bar: 'baz', baz: 'quz'}); console.log( object.map(value =&gt; value .split('') .reverse() .join('') ) ); // {foo: 'rab', bar: 'zab', baz: 'zuq'} merge(object1: Object[, object2: Object[, ...objectN: Object]]): CrioObject Merge any number of objects into existing CrioObject Supports shallow or deep values via array or dot-bracket syntax const object = crio({foo: 'bar', bar: ['baz', 'quz']}); console.log(object.merge(null, {baz: 'quz'})); // {foo: 'bar', bar: ['baz', 'quz'], baz: 'quz'} console.log(object.merge('bar[0]', ['blah'])); // {foo: 'bar', bar: ['baz', 'quz', 'blah']}; mutate(fn: function(object: Object, crio: CrioObject)): any Whatever you return in the callback is what is returned (as a CrioArray or CrioObject if applicable) const object = crio({foo: ['bar', 'baz']}); const result = object.mutate(thawed =&gt; { thawed.foo.push('quz'); thawed.bar = 'baz'; return thawed; }); console.log(result); // {foo: ['bar', 'baz', 'quz'], bar: 'baz'} pluck(key: (Array&lt;number|string&gt;|string)): CrioArray Iterates over the CrioObject and returns a CrioArray of values where the key exists as a property on the collection item Supports shallow or deep values via array or dot-bracket syntax Iteration order is not guaranteed (due to object key order not being guaranteed per the spec) const object = crio({ first: {foo: 'bar'}, second: {bar: 'baz'}, third: null, fourth: {foo: 'foo'} }); console.log(object.pluck('foo')); // ['bar', undefined, undefined, 'foo'] const otherObject = crio({ first: [{foo: 'foo'}, {bar: 'baz'}, {foo: 'bar'}], second: [{foo: 'bar'}, {bar: 'baz'}, null, {foo: 'foo'}] }); console.log(otherObject.pluck('second.foo')); // ['bar', undefined, undefined, 'foo'] reduce(fn: function(accumulator: any, value: any, key: string, object:CrioObject)): any Performs same function as reduce in CrioArray, but on the CrioObject const object = crio({one: 1, two; 2, three: 3}); const result = object.reduce(({order, sum}, value) =&gt; { return {order: [...order, value], sum: sum + value}; }, {order: [], sum; 0}); console.log(result); // {order: [1, 2, 3], sum: 6} reduceRight(fn: function(accumulator: any, value: any, key: string, object:CrioObject)): any Performs same function as reduceRight in CrioArray, but on the CrioObject const object = crio({one: 1, two; 2, three: 3}); const result = object.reduceRight(({order, sum}, value) =&gt; { return {order: [...order, value], sum: sum + value}; }, {order: [], sum; 0}); console.log(result); // {order: [3, 2, 1], sum: 6} set(key: (Array&lt;number|string&gt;|string), value: any): CrioObject Sets value at key Supports shallow or deep values via array or dot-bracket syntax const object = crio({foo: 'bar', bar: ['baz', 'quz']}); console.log(object.set('bar', 'baz')); // {foo: 'bar', bar: 'baz'} console.log(object.set('bar[0]', {baz: 'blah'})); // {foo: 'bar', bar: [{baz: 'blah'}, 'quz']} some(fn: function(value: any, key: string, object: CrioObject)): boolean Performs same function as some in CrioArray, but on the CrioObject const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.some(value =&gt; value === 'baz')); // true console.log(object.some(value =&gt; value === 'quz')); // false toArray(): CrioArray Converts CrioObject to a CrioArray of the object's values const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.toArray()); // ['bar', 'baz'] toLocaleString Returns stringified version of CrioObject Optionally accepts serializer and indent arguments, which are identical to those arguments for JSON.stringify const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.toLocaleString()); // {&quot;foo&quot;:&quot;bar&quot;,&quot;bar&quot;:&quot;baz&quot;} console.log(object.toLocaleString(null, 2)); /* { &quot;foo&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;baz&quot; } */ toString Returns stringified version of CrioObject Optionally accepts serializer and indent arguments, which are identical to those arguments for JSON.stringify const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.toString()); // {&quot;foo&quot;:&quot;bar&quot;,&quot;bar&quot;:&quot;baz&quot;} console.log(object.toString(null, 2)); /* { &quot;foo&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;baz&quot; } */ thaw(): Object Recursively thaws CrioObject deeply and returns standard object version of itself const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.thaw()); // {foo: 'bar', bar: 'baz'} console.log(object.constructor === Object); // false console.log(object.thaw().constructor === Object); // true values(): CrioObject Returns a CrioArray of the values in the CrioObject const object = crio({foo: 'bar', bar: 'baz'}); console.log(object.values()); // ['bar', 'baz'] Ã— Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>

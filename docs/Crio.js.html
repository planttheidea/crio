<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>crio Source: Crio.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cyborg.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">crio</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-Crio.html">Crio</a></li><li><a href="module-crio_.html">crio</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-Crio.Crio.html">Crio.Crio</a></li><li><a href="module-Crio.CrioArray.html">Crio.CrioArray</a></li><li><a href="module-Crio.CrioObject.html">Crio.CrioObject</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="tutorial-API.html">API</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: Crio.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">// external dependencies
import hashIt from 'hash-it';
import every from 'lodash/every';
import fill from 'lodash/fill';
import find from 'lodash/find';
import findKey from 'lodash/findKey';
import findLastKey from 'lodash/findLastKey';
import isArray from 'lodash/isArray';
import isUndefined from 'lodash/isUndefined';
import filter from 'lodash/filter';
import forEach from 'lodash/forEach';
import get from 'lodash/fp/get';
import map from 'lodash/map';
import merge from 'lodash/merge';
import reduce from 'lodash/reduce';
import reduceRight from 'lodash/reduceRight';
import set from 'lodash/fp/set';
import slice from 'lodash/slice';
import some from 'lodash/some';
import toPairs from 'lodash/toPairs';
import values from 'lodash/values';

// constants
import {
  CRIO_ARRAY_TYPE,
  CRIO_OBJECT_TYPE,
  CRIO_SYMBOL,
  CRIO_TYPE,
  ITERATOR_PROPERTY_DESCRIPTOR,
  UNSCOPABLES_PROPERTY_DESCRIPTOR
} from './constants';

// utils
import {
  createAssignToObject,
  freeze,
  getCorrectConstructor,
  getCrioValue,
  getKeysMetadata,
  getRelativeValue,
  getStandardValue,
  hasOwnProperty,
  isCrio,
  isCrioArray,
  isEqual,
  keys,
  stringify
} from './utils';

/**
 * @module Crio
 */

let assignToObject;

/**
 * @class Crio
 * @classdesc base crio class
 *
 * @memberof module:Crio
 */
export class Crio {
  /**
   * @function constructor
   *
   * @description
   * add the items to the crio, and return a frozen version
   *
   * @param {Object} object object passed for crioing
   * @returns {Crio} crioed object
   */
  constructor(object) {
    forEach(object, assignToObject(this, getCrioValue));

    return freeze(this);
  }

  /**
   * @static
   */
  static get ['@@species']() {
    return this;
  }

  get [CRIO_SYMBOL]() {
    return true;
  }

  get hashCode() {
    return hashIt(this);
  }

  /**
   * @function clear
   * @memberof! Crio#
   *
   * @description
   * get a new crio that is empty
   *
   * @returns {Crio} new empty crio instance
   */
  clear() {
    return new this.constructor(this.isArray() ? [] : {});
  }

  /**
   * @function compact
   *
   * @description
   * remove all falsy values from the crio
   *
   * @returns {Crio} new crio instance
   */
  compact() {
    return this.filter((value) => {
      return !!value;
    });
  }

  /**
   * @function delete
   *
   * @description
   * remove an item from the crio
   *
   * @param {number|string} key the key to remove from the crio
   * @returns {Crio} new crio instance with item removed
   */
  delete(key) {
    let updated = {...this};

    delete updated[key];

    if (this.isArray()) {
      updated = map(updated);
    }

    return new this.constructor(updated);
  }

  /**
   * @function deleteIn
   *
   * @description
   * remove a nested item from the crio
   *
   * @param {Array&lt;number|string>} keys the path of the item to remove
   * @returns {Crio} new crio instance with the item removed
   */
  deleteIn(keys) {
    if (!keys || !keys.length) {
      return this;
    }

    if (keys.length === 1) {
      return this.delete(keys[0]);
    }

    const {currentValue, lastIndex, parentKeys} = getKeysMetadata(keys, this);

    if (!isCrio(currentValue)) {
      return this;
    }

    const updated = currentValue.delete(keys[lastIndex]);

    return this.setIn(parentKeys, updated);
  }

  /**
   * @function entries
   *
   * @description
   * get the pairs of [key, value] in the crio
   *
   * @returns {Array&lt;Array&lt;string>>} [key, value] pairs
   */
  entries() {
    return toPairs(this);
  }

  /**
   * @function equals
   *
   * @description
   * does the object passed equal the crio
   *
   * @param {*} object object to compare against the instance
   * @returns {boolean} is the object equal
   */
  equals(object) {
    return isEqual(this, object);
  }

  /**
   * @function every
   *
   * @description
   * does every instance in the crio match
   *
   * @param {function} fn the function to test for matching
   * @param {*} [thisArg=this] argument for "this" to use in the iteration
   * @returns {boolean} does every instance match
   */
  every(fn, thisArg = this) {
    return every(this, fn, thisArg);
  }

  /**
   * @function filter
   *
   * @description
   * get a reduced set from the crio
   *
   * @param {function} fn function to test for if it should be returned or not
   * @param {*} [thisArg=this] argument for "this" to use in the iteration
   * @returns {Crio} new crio instance
   */
  filter(fn, thisArg = this) {
    const updated = this.isArray()
      ? filter(this, fn, thisArg)
      : reduce(
          this,
          (updatedValue, value, key) => {
            if (fn.call(thisArg, value, key, this)) {
              updatedValue[key] = value;
            }

            return updatedValue;
          },
          {}
        );

    return new this.constructor(updated);
  }

  /**
   * @function find
   *
   * @description
   * find an item in the crio if it exists
   *
   * @param {function} fn function to test for finding the item
   * @param {number} [fromKey] key to start from when performing the find
   * @returns {*} found item or undefined
   */
  find(fn, fromKey) {
    return find(this, fn, fromKey);
  }

  /**
   * @function forEach
   *
   * @description
   * iterate over the crio calling fn
   *
   * @param {function} fn function to call in iteration
   * @param {*} [thisArg=this] argument to use as "this" in the iteration
   * @returns {Crio} new crio instance
   */
  forEach(fn, thisArg = this) {
    forEach(this, fn, thisArg);

    return this;
  }

  /**
   * @function get
   *
   * @description
   * get the item at key passed
   *
   * @param {number|string} key key to retrieve
   * @returns {*} item found at key
   */
  get(key) {
    return this[key];
  }

  /**
   * @function getIn
   *
   * @description
   * get the nested item at the path passed
   *
   * @param {Array&lt;number|string>} keys path to retrieve from
   * @returns {*} item found at nested path
   */
  getIn(keys) {
    if (!keys || !keys.length) {
      return this;
    }

    return get(keys, this);
  }

  /**
   * @function has
   *
   * @description
   * does the crio have the key passed
   *
   * @param {number|string} key key to test
   * @returns {boolean} does the crio have the key
   */
  has(key) {
    return hasOwnProperty.call(this, key);
  }

  /**
   * @function hasIn
   *
   * @description
   * does the crio have the nested key at the path passed
   *
   * @param {Array&lt;number|string>} keys path to test
   * @returns {boolean} does the crio have the nested path
   */
  hasIn(keys) {
    if (!keys || !keys.length) {
      return false;
    }

    if (keys.length === 1) {
      return this.has(keys[0]);
    }

    const {currentValue, lastIndex} = getKeysMetadata(keys, this);

    return isCrio(currentValue) &amp;&amp; currentValue.has(keys[lastIndex]);
  }

  /**
   * @function includes
   *
   * @description
   * does the crio have the value passed
   *
   * @param {*} value value to test for existence
   * @returns {boolean} does the value exist in the crio
   */
  includes(value) {
    return this.some((currentValue) => {
      return currentValue === value;
    });
  }

  /**
   * @function isArray
   *
   * @description
   * is the crio an array
   *
   * @returns {boolean} is the crio an array
   */
  isArray() {
    return this[CRIO_TYPE] === CRIO_ARRAY_TYPE;
  }

  /**
     * @function isObject
     *
     * @description
     * is the crio an object
     *
     * @returns {boolean} is the crio an object
     */
  isObject() {
    return this[CRIO_TYPE] === CRIO_OBJECT_TYPE;
  }

  /**
   * @function keys
   *
   * @description
   * get the keys of the crio
   *
   * @returns {Array&lt;string>} keys in the crio
   */
  keys() {
    return keys(this);
  }

  /**
   * @function map
   *
   * @description
   * iterate over the crio mapping the result of fn to the key
   *
   * @param {function} fn function to call on iteration
   * @param {*} [thisArg=this] argument to use as "this" in the iteration
   * @returns {Crio} new crio instance
   */
  map(fn, thisArg = this) {
    const updated = this.isArray()
      ? map(this, fn, thisArg)
      : reduce(
          this,
          (updatedValue, value, key) => {
            updatedValue[key] = fn.call(thisArg, value, key, this);

            return updatedValue;
          },
          {}
        );

    return new this.constructor(updated);
  }

  /**
   * @function merge
   *
   * @description
   * merge objects with crio
   *
   * @param {...Array&lt;CrioArray|CrioObject|Object>} objects objects to merge with the crio
   * @returns {Crio} new crio instance
   */
  merge(...objects) {
    if (!objects.length) {
      return this;
    }

    const merged = merge({}, this.thaw(), ...objects);

    return new this.constructor(merged);
  }

  /**
   * @function mergeIn
   *
   * @description
   * merge the objects passed at the nested path in the crioArray
   *
   * @param {Array&lt;number|string>} keys path to merge into
   * @param {...Array&lt;CrioArray|CrioObject|Object>} objects objects to merge with the crio
   * @returns {Crio} new crio instance
   */
  mergeIn(keys, ...objects) {
    if (!keys || !keys.length) {
      return this;
    }

    const valueToMerge = this.getIn(keys);

    if (!isCrio(valueToMerge)) {
      return this.setIn(keys, merge({}, ...objects));
    }

    const updated = this.setIn(keys, valueToMerge.merge(...objects));

    return new this.constructor(updated);
  }

  /**
   * @function mutate
   *
   * @description
   * work with the object in a mutated way and return the crioed result of that call
   *
   * @param {function} fn function to apply to crio
   * @param {*} [thisArg=this] argument to use for "this" in the call
   * @returns {*} crioed value resulting from the call
   */
  mutate(fn, thisArg = this) {
    const result = fn.call(thisArg, this.thaw(), this);

    return getCrioValue(
      result,
      getCorrectConstructor(result, CrioArray, CrioObject)
    );
  }

  /**
   * @function pluck
   *
   * @description
   * get the values in each object in the collection at key
   *
   * @param {string} key key to find value of in collection object
   * @returns {Crio} new crio instance
   */
  pluck(key) {
    let plucked;

    return this.reduce((pluckedValues, value) => {
      plucked = !!(value &amp;&amp; hasOwnProperty.call(value, key))
        ? value[key]
        : undefined;

      return [...pluckedValues, plucked];
    }, []);
  }

  /**
     * @function pluckIn
     *
     * @description
     * get the values in each object in the collection at the nested path
     *
     * @param {Array&lt;number|string>} keys keys to find value of in collection object
     * @returns {Crio} new crio instance
     */
  pluckIn(keys) {
    if (!keys || !keys.length) {
      return new CrioArray([]);
    }

    if (keys.length === 1) {
      return this.pluck(keys[0]);
    }

    const {currentValue, lastIndex} = getKeysMetadata(keys, this);

    if (!isCrio(currentValue)) {
      return this;
    }

    return currentValue.pluck(keys[lastIndex]);
  }

  /**
   * @function reduce
   *
   * @description
   * reduce the crio down to a single value, starting with initial value
   *
   * @param {function} fn the function to iterate with
   * @param {*} initialValue the initial value of the reduction
   * @param {*} [thisArg=this] argument to use for "this" in the call of fn
   * @returns {*} the reduced value
   */
  reduce(fn, initialValue, thisArg = this) {
    const reducedValue = reduce.call(thisArg, this, fn, initialValue);

    return getCrioValue(
      reducedValue,
      getCorrectConstructor(reducedValue, CrioArray, CrioObject)
    );
  }

  /**
   * @function reduceRight
   *
   * @description
   * reduce the crio down to a single value, starting with initial value, in reverse order
   *
   * @param {function} fn the function to iterate with
   * @param {*} initialValue the initial value of the reduction
   * @param {*} [thisArg=this] argument to use for "this" in the call of fn
   * @returns {*} the reduced value
   */
  reduceRight(fn, initialValue, thisArg = this) {
    const reducedValue = reduceRight.call(thisArg, this, fn, initialValue);

    return getCrioValue(
      reducedValue,
      getCorrectConstructor(reducedValue, CrioArray, CrioObject)
    );
  }

  /**
   * @function set
   *
   * @description
   * set the value at the key passed
   *
   * @param {number|string} key key to assign value to
   * @param {*} value value to assign
   * @returns {Crio} new crio instance
   */
  set(key, value) {
    const updated = {
      ...this,
      [key]: value
    };

    return new this.constructor(updated);
  }

  /**
   * @function setIn
   *
   * @description
   * deeply set the value at the path passed
   *
   * @param {Array&lt;number|string>} keys path to assign value to
   * @param {*} value value to assign
   * @returns {Crio} new crio instance
   */
  setIn(keys, value) {
    if (!keys || !keys.length) {
      return this;
    }

    const updatedObject = set(keys, value, this);

    return new this.constructor(updatedObject);
  }

  /**
   * @function some
   *
   * @description
   * do any of the items in crio match per the fn passed
   *
   * @param {function} fn fn to iterate with
   * @param {*} [thisArg=this] argument to use as "this" in the iteration
   * @returns {boolean} are there any matches
   */
  some(fn, thisArg = this) {
    return some(this, fn, thisArg);
  }

  /**
   * @function thaw
   *
   * @description
   * create a plain JS version of the crio
   *
   * @returns {Array&lt;*>|Object} plain JS version of crio
   */
  thaw() {
    const returnValue = this.isArray() ? [] : {};

    forEach(this, assignToObject(returnValue, getStandardValue));

    return returnValue;
  }

  /**
   * @function toArray
   *
   * @description
   * convert the crio to an array if it isnt already
   *
   * @returns {CrioArray} new crio array instance
   */
  toArray() {
    return this.isArray() ? this : new CrioArray(this.values());
  }

  /**
   * @function toLocaleString
   *
   * @description
   * convert the crio to stringified form
   *
   * @returns {string} stringified crio
   */
  toLocaleString() {
    return this.toString();
  }

  /**
   * @function toObject
   *
   * @description
   * convert the crio to an object if it isnt already
   *
   * @returns {CrioObject} new crio object instance
   */
  toObject() {
    if (this.isObject()) {
      return this;
    }

    const updated = reduce(
      this,
      (object, value, key) => {
        object[key] = value;

        return object;
      },
      {}
    );

    return new CrioObject(updated);
  }

  /**
   * @function toLocaleString
   *
   * @description
   * convert the crio to stringified form
   *
   * @returns {string} stringified crio
   */
  toString() {
    return stringify(this);
  }

  /**
   * @function valueOf
   *
   * @description
   * noop for valueOf
   *
   * @returns {Crio} the same crio instance
   */
  valueOf() {
    return this;
  }

  /**
   * @function values
   *
   * @description
   * get the values of the crio as an array
   *
   * @returns {Array&lt;*>} values in the crio
   */
  values() {
    return values(this);
  }
}

Object.defineProperties(Crio.prototype, {
  [Symbol.iterator]: ITERATOR_PROPERTY_DESCRIPTOR,
  [Symbol.unscopables]: UNSCOPABLES_PROPERTY_DESCRIPTOR
});

/**
 * @class CrioArray
 * @classdesc extension of Crio class specific to arrays
 *
 * @memberof module:Crio
 */
export class CrioArray extends Crio {
  get length() {
    return keys(this).length;
  }

  /**
   * @function concat
   *
   * @description
   * append the items passed to the crio
   *
   * @param {...Array&lt;*>} items items to append to the crio
   * @returns {CrioArray} new crio array instance
   */
  concat(items) {
    const concatted = [...this.thaw(), ...items];

    return new CrioArray(concatted);
  }

  /**
   * @function copyWithin
   *
   * @description
   * move values around within the array
   *
   * @param {number} target target to copy
   * @param {number} [start=0] index to start copying to
   * @param {number} [end=this.length] index to stop copying to
   * @returns {CrioArray} new crio array instance
   */
  copyWithin(target, start = 0, end = this.length) {
    const copiedArray = this.thaw();
    const length = this.length >>> 0;

    let to = getRelativeValue(target >> 0, length),
      from = getRelativeValue(start >> 0, length);

    const final = getRelativeValue(end >> 0, length);

    let count = Math.min(final - from, length - to),
      direction = 1;

    if (from &lt; to &amp;&amp; to &lt; from + count) {
      direction = -1;
      from += count - 1;
      to += count - 1;
    }

    while (count > 0) {
      if (from in copiedArray) {
        copiedArray[to] = copiedArray[from];
      } else {
        delete copiedArray[to];
      }

      from += direction;
      to += direction;
      count--;
    }

    return new CrioArray(copiedArray);
  }

  /**
   * @function difference
   *
   * @description
   * find the values in this that do not exist in any of the arrays passed
   *
   * @param {Array&lt;Array>} arrays arrays to get the difference of
   * @returns {CrioArray} array of items matching diffference criteria
   */
  difference(...arrays) {
    if (!arrays.length) {
      return this;
    }

    let indexOfValue;

    const difference = reduce(
      arrays,
      (differenceArray, array) => {
        if (isArray(array) || isCrioArray(array)) {
          forEach(array, (value) => {
            indexOfValue = differenceArray.indexOf(value);

            if (!!~indexOfValue) {
              differenceArray.splice(indexOfValue, 1);
            }
          });
        }

        return differenceArray;
      },
      this.thaw()
    );

    return new CrioArray(difference);
  }

  /**
   * @function fill
   *
   * @description
   * fill the array at certain indices with the value passed
   *
   * @param {*} value the value to fill the indices with
   * @param {number} [start=0] the starting index to fill
   * @param {number} [end=this.length] the ending index to fill
   * @returns {CrioArray} new crio array instance
   */
  fill(value, start = 0, end = this.length) {
    const filled = fill(this.thaw(), value, start, end);

    return new CrioArray(filled, this);
  }

  /**
   * @function findIndex
   *
   * @description
   * find the matching index based on truthy return from fn
   *
   * @param {function} fn function to use for test in iteration
   * @param {*} [thisArg=this] argument to use as "this" in fn call
   * @returns {number} index of match, or -1
   */
  findIndex(fn, thisArg = this) {
    const index = findKey(this, (value, key) => {
      return fn.call(thisArg, value, +key, this);
    });

    return isUndefined(index) ? -1 : +index;
  }

  /**
   * @function findLastIndex
   *
   * @description
   * find the matching index based on truthy return from fn starting from end
   *
   * @param {function} fn function to use for test in iteration
   * @param {*} [thisArg=this] argument to use as "this" in fn call
   * @returns {number} index of match, or -1
   */
  findLastIndex(fn, thisArg = this) {
    const index = findLastKey(this, (value, key) => {
      return fn.call(thisArg, value, +key, this);
    });

    return isUndefined(index) ? -1 : +index;
  }

  /**
   * @function first
   *
   * @description
   * take the first n number of items in the array
   *
   * @param {number} [size=1] size of elements to take from beginning of array
   * @returns {CrioArray}
   */
  first(size = 1) {
    return this.slice(0, size);
  }

  /**
   * @function indexOf
   *
   * @description
   * get the index of the value passed
   *
   * @param {*} value value to find in crio
   * @returns {number} index of match, or -1
   */
  indexOf(value) {
    return this.findIndex((thisValue) => {
      return thisValue === value;
    });
  }

  /**
   * @function intersection
   *
   * @description
   * find the values in that exist in this and each of the arrays passed
   *
   * @param {Array&lt;Array>} arrays
   * @returns {CrioArray}
   */
  intersection(...arrays) {
    if (!arrays.length) {
      return this;
    }

    const allArrays = [this, ...arrays];
    const allArraysLength = allArrays.length;

    let indices = [],
      indexOfValue;

    const reducedArrays = reduce(
      allArrays,
      (values, array) => {
        if (isArray(array) || isCrioArray(array)) {
          forEach(array, (value) => {
            indexOfValue = values.indexOf(value);

            if (!!~indexOfValue) {
              indices[indexOfValue]++;
            } else {
              indices[values.length] = 1;
              values.push(value);
            }
          });
        }

        return values;
      },
      []
    );
    const filteredArrays = filter(reducedArrays, (value, index) => {
      return indices[index] === allArraysLength;
    });

    return new CrioArray(filteredArrays);
  }

  /**
   * @function join
   *
   * @description
   * join the values in the crio as a string, combined with separator
   *
   * @param {string} [separator=','] character(s) to place between strings in combination
   * @returns {string} parameters joined by separator in string
   */
  join(separator = ',') {
    return this.thaw().join(separator);
  }

  /**
   * @function last
   *
   * @description
   * take the last n number of items in the array
   *
   * @param {number} [size=1] size of elements to take from end of array
   * @returns {CrioArray}
   */
  last(size = 1) {
    return this.slice(this.length - size);
  }

  /**
   * @function lastIndexOf
   *
   * @description
   * get the last index of the value passed
   *
   * @param {*} value value to find in crio
   * @returns {number} index of match, or -1
   */
  lastIndexOf(value) {
    return this.findLastIndex((thisValue) => {
      return thisValue === value;
    });
  }

  /**
   * @function pop
   *
   * @description
   * get crio based on current crio with last item removed
   *
   * @returns {CrioArray} new crio array instance
   */
  pop() {
    return this.slice(0, this.length - 1);
  }

  /**
   * @function reverse
   *
   * @description
   * get the same values, but in reverse order
   *
   * @returns {CrioArray} new crio array instance
   */
  reverse() {
    let reversed = this.thaw();

    reversed.reverse();

    return new CrioArray(reversed);
  }

  /**
   * @function shift
   *
   * @description
   * get crio based on current crio with first item removed
   *
   * @returns {CrioArray} new crio array instance
   */
  shift() {
    return this.slice(1);
  }

  /**
   * @function slice
   *
   * @description
   * get a new crio array based on a subset of the current crio
   *
   * @param {number} [start=0] first index to include
   * @param {number} [end=this.length] size of array from first index
   * @returns {CrioArray} new crio array instance
   */
  slice(start = 0, end = this.length) {
    const sliced = slice(this, start, end);

    return new CrioArray(sliced);
  }

  /**
   * @function sort
   *
   * @description
   * sort the collection by the fn passed
   *
   * @param {function} fn the function to sort based on
   * @returns {CrioArray} new crio array instance
   */
  sort(fn) {
    let sorted = this.thaw();

    sorted.sort(fn);

    return new CrioArray(sorted);
  }

  /**
   * @function splice
   *
   * @description
   * splice the values into or out of the array
   *
   * @param {number} [start=0] starting index to splice
   * @param {number} [deleteCount=1] length from starting index to removes
   * @param {...Array&lt;*>} items items to insert after delete is complete
   * @returns {CrioArray} new crio array instance
   */
  splice(start = 0, deleteCount = 1, ...items) {
    let spliced = this.thaw();

    spliced.splice(start, deleteCount, ...items);

    return new CrioArray(spliced);
  }

  /**
   * @function unique
   *
   * @description
   * return the current CrioArray with the duplicate values removed
   *
   * @returns {CrioArray} new crio instance
   */
  unique() {
    let hashArray = [],
      newArray = [],
      hasHashCode = false,
      hashCode,
      storeValue;

    return this.filter((value) => {
      hashCode = !!value ? value.hashCode : undefined;
      hasHashCode = !isUndefined(hashCode);
      storeValue =
        !~newArray.indexOf(value) &amp;&amp;
        (!hasHashCode || !~hashArray.indexOf(hashCode));

      if (storeValue) {
        newArray.push(value);

        if (hasHashCode) {
          hashArray.push(hashCode);
        }
      }

      return storeValue;
    });
  }

  /**
   * @function unshift
   *
   * @description
   * add items passed to the beginning of the crio array
   *
   * @param {...Array&lt;*>} items items to prepend to the array
   * @returns {CrioArray} new crio array instance
   */
  unshift(...items) {
    return items.length ? new CrioArray([...items, ...this.thaw()]) : this;
  }

  /**
   * @function xor
   *
   * @description
   * find the values that are the symmetric difference of this and the arrays passed
   *
   * @param {Array&lt;Array>} arrays arrays to find symmetric values in
   * @returns {CrioArray} new crio array instance
   */
  xor(...arrays) {
    if (!arrays.length) {
      return this;
    }

    const allArrays = [this, ...arrays];

    let indicesToRemove = [],
      indexOfValue;

    const reducedValues = reduce(
      allArrays,
      (values, array) => {
        if (isArray(array) || isCrioArray(array)) {
          forEach(array, (value) => {
            indexOfValue = values.indexOf(value);

            if (!!~indexOfValue) {
              indicesToRemove.push(indexOfValue);
            } else {
              values.push(value);
            }
          });
        }

        return values;
      },
      []
    );
    const xorValues = filter(reducedValues, (value, index) => {
      return !~indicesToRemove.indexOf(index);
    });

    return new CrioArray(xorValues);
  }
}

Object.defineProperties(CrioArray.prototype, {
  [CRIO_TYPE]: {
    configurable: false,
    enumerable: false,
    value: CRIO_ARRAY_TYPE,
    writable: false
  }
});

/**
 * @class CrioObject
 * @classdesc extension of Crio class specific to objects
 *
 * @memberof module:Crio
 */
export class CrioObject extends Crio {
  get size() {
    return keys(this).length;
  }

  /**
   * @function findKey
   *
   * @description
   * find a specific key based on a matching function
   *
   * @param {function} fn function to match
   * @returns {string|undefined} key matching fn
   */
  findKey(fn) {
    return findKey(this, fn);
  }

  /**
   * @function findLastKey
   *
   * @description
   * find a specific key based on a matching function, starting from the end
   *
   * @param {function} fn function to match
   * @returns {string|undefined} key matching fn
   */
  findLastKey(fn) {
    return findLastKey(this, fn);
  }
}

Object.defineProperties(CrioObject.prototype, {
  [CRIO_TYPE]: {
    configurable: false,
    enumerable: false,
    value: CRIO_OBJECT_TYPE,
    writable: false
  }
});

assignToObject = createAssignToObject(CrioArray, CrioObject);
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->

<script>
	$( function () {
		$( '#main' ).localScroll( {
			offset : { top : 60 } //offset by the height of your header (give or take a few px, see what works for you)
		} );
		$( "dt.name" ).each( function () {
			var $this = $( this ).find("h4");
			var icon = $( "<i/>" ).addClass( "icon-plus-sign" ).addClass( "pull-right" ).addClass( "icon-white" );
			var dt = $(this);
			var children = dt.next( "dd" );

			dt.prepend( icon ).css( {cursor : "pointer"} );
			dt.addClass( "member-collapsed" ).addClass( "member" );


			children.hide();

			dt.children().on( "click", function () {
				children = dt.next( "dd" );
				children.slideToggle( "fast", function () {

					if ( children.is( ":visible" ) ) {
						icon.addClass( "icon-minus-sign" ).removeClass( "icon-plus-sign" ).removeClass( "icon-white" );
						dt.addClass( "member-open" ).animate( "member-collapsed" );
					} else {
						icon.addClass( "icon-plus-sign" ).removeClass( "icon-minus-sign" ).addClass( "icon-white" );
						dt.addClass( "member-collapsed" ).removeClass( "member-open" );
					}
				} );
			} );

		} );
	} );
</script>


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
